/******************************************************************************/
/*           Generated by IBExpert 2022.6.10.1 28/09/2022 22:39:03            */
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES UTF8;

SET CLIENTLIB 'D:\GIT\tetram\bdtheque\delphi\trunk\deploy\Win32\fbembed.dll';

CREATE DATABASE 'D:\GIT\tetram\bdtheque\delphi\trunk\deploy\BD.GDB'
    USER 'SYSDBA'
    PAGE_SIZE 16384
    DEFAULT CHARACTER SET UTF8 COLLATION UTF8_FR_CI_AI;



/******************************************************************************/
/*                        User defined functions (UDF)                        */
/******************************************************************************/

DECLARE EXTERNAL FUNCTION UDF_CREATEGUID

    RETURNS CSTRING(38) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'CreateGUID' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_DELETEFILE
    CSTRING(32767) CHARACTER SET NONE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'DeleteFile' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_EXTRACTFILEATTR
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'ExtractFileAttr' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_EXTRACTFILENAME
    INTEGER
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'ExtractFileName' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_EXTRACTFILESIZE
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'ExtractFileSize' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_FINDFILEFIRST
    CSTRING(32767) CHARACTER SET NONE,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'FindFileFirst' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_FINDFILENEXT
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'FindFileNext' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_FORMATTITLE
    CSTRING(32767) CHARACTER SET NONE
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'FormatTitle' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_IDENTICALSTRING
    CSTRING(32767) CHARACTER SET NONE,
    CSTRING(32767) CHARACTER SET NONE
    RETURNS FLOAT BY VALUE
    ENTRY_POINT 'IdenticalString' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_IDENTICALSTRING1
    CSTRING(32767) CHARACTER SET NONE,
    CSTRING(32767) CHARACTER SET NONE
    RETURNS FLOAT BY VALUE
    ENTRY_POINT 'IdenticalString1' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_IDENTICALSTRING2
    CSTRING(32767) CHARACTER SET NONE,
    CSTRING(32767) CHARACTER SET NONE
    RETURNS FLOAT BY VALUE
    ENTRY_POINT 'IdenticalString2' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_LENGTH
    CSTRING(32767) CHARACTER SET NONE
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'Length' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_LOADBLOBFROMFILE
    CSTRING(32767) CHARACTER SET NONE,
    CSTRING(32767) CHARACTER SET NONE,
    BLOB
    RETURNS PARAMETER 3
    ENTRY_POINT 'LoadBlobFromFile' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_SAVEBLOBTOFILE
    CSTRING(32767) CHARACTER SET NONE,
    CSTRING(32767) CHARACTER SET NONE,
    BLOB
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'SaveBlobToFile' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_SEARCHFILENAME
    CSTRING(32767) CHARACTER SET NONE,
    CSTRING(32767) CHARACTER SET NONE,
    INTEGER
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'SearchFileName' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_SOUNDEX
    CSTRING(32767) CHARACTER SET NONE,
    INTEGER
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'Soundex' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_SUBSTRING
    CSTRING(32767) CHARACTER SET NONE,
    INTEGER,
    INTEGER
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'SubString' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_TRIM
    CSTRING(32767) CHARACTER SET NONE
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'Trim' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_UPPER
    CSTRING(32767) CHARACTER SET NONE
    RETURNS CSTRING(32767) CHARACTER SET NONE FREE_IT
    ENTRY_POINT 'Upper' MODULE_NAME 'BDT_UDF.dll';


DECLARE EXTERNAL FUNCTION UDF_UPPERBLOB
    BLOB,
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'UpperBlob' MODULE_NAME 'BDT_UDF.dll';




/******************************************************************************/
/*                                 Collations                                 */
/******************************************************************************/

CREATE COLLATION UTF8_FR
    FOR UTF8
    FROM UNICODE
    PAD SPACE
    CASE SENSITIVE
    ACCENT SENSITIVE
    'LOCALE=fr_FR';

CREATE COLLATION UTF8_FR_CI
    FOR UTF8
    FROM UNICODE
    PAD SPACE
    CASE INSENSITIVE
    ACCENT SENSITIVE
    'LOCALE=fr_FR';

CREATE COLLATION UTF8_FR_CI_AI
    FOR UTF8
    FROM UNICODE
    PAD SPACE
    CASE INSENSITIVE
    ACCENT INSENSITIVE
    'LOCALE=fr_FR';



/******************************************************************************/
/*                                  Domains                                   */
/******************************************************************************/

CREATE DOMAIN T_DESCRIPTION AS
    BLOB SUB_TYPE 1 SEGMENT SIZE 80 CHARACTER SET ISO8859_1
COLLATE FR_FR_CI_AI;

CREATE DOMAIN T_DESCRIPTION_UTF8 AS
    BLOB SUB_TYPE 1 SEGMENT SIZE 80 CHARACTER SET UTF8
COLLATE UTF8_FR_CI_AI;

CREATE DOMAIN T_GUID AS
    CHAR(38) CHARACTER SET NONE
COLLATE NONE;

CREATE DOMAIN T_GUID_NOTNULL AS
    CHAR(38) CHARACTER SET NONE
NOT NULL
COLLATE NONE;

CREATE DOMAIN T_IDENT50 AS
    VARCHAR(50) CHARACTER SET ISO8859_1
COLLATE FR_FR_CI_AI;

CREATE DOMAIN T_IDENT50_UTF8 AS
    VARCHAR(50) CHARACTER SET UTF8
COLLATE UTF8_FR_CI_AI;

CREATE DOMAIN T_INITIALE AS
    CHAR(1) CHARACTER SET ISO8859_1
COLLATE FR_FR_CI_AI;

CREATE DOMAIN T_INITIALE_UTF8 AS
    CHAR(1) CHARACTER SET UTF8
COLLATE UTF8_FR_CI_AI;

CREATE DOMAIN T_NOM AS
    VARCHAR(150) CHARACTER SET ISO8859_1
COLLATE FR_FR_CI_AI;

CREATE DOMAIN T_NOM_UTF8 AS
    VARCHAR(150) CHARACTER SET UTF8
COLLATE UTF8_FR_CI_AI;

CREATE DOMAIN T_REFNOTNULL AS
    INTEGER
    DEFAULT NULL
    NOT NULL;

CREATE DOMAIN T_REFNOTNULL_BASE0 AS
    INTEGER
    DEFAULT 0
    NOT NULL;

CREATE DOMAIN T_SITEWEB AS
    VARCHAR(255) CHARACTER SET UTF8
COLLATE UTF8;

CREATE DOMAIN T_SOUNDEX_UTF8 AS
    VARCHAR(30) CHARACTER SET UTF8
COLLATE UTF8_FR_CI_AI;

CREATE DOMAIN T_TIMESTAMP_NOTNULL AS
    TIMESTAMP
    NOT NULL;

CREATE DOMAIN T_TITRE AS
    VARCHAR(150) CHARACTER SET ISO8859_1
COLLATE FR_FR_CI_AI;

CREATE DOMAIN T_TITRE_UTF8 AS
    VARCHAR(150) CHARACTER SET UTF8
COLLATE UTF8_FR_CI_AI;

CREATE DOMAIN T_YESNO AS
    SMALLINT
    DEFAULT 0
    CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1));

CREATE DOMAIN T_YESNO_BASENO AS
    SMALLINT
    DEFAULT 0
    CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1));

CREATE DOMAIN T_YESNO_BASEYES AS
    SMALLINT
    DEFAULT 1
    CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1));



/******************************************************************************/
/*                                 Exceptions                                 */
/******************************************************************************/

CREATE EXCEPTION IDSERIE_UNKNOWN 'ID_SERIE inconnu';



/******************************************************************************/
/*                             Stored procedures                              */
/******************************************************************************/

CREATE PROCEDURE ACHATALBUMS_BY_EDITEUR (
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_ANNEE (
    ANNEE SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_AUTEUR (
    ID_AUTEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN PERSONNES.ID_PERSONNE */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    METIER SMALLINT /* TYPE OF COLUMN AUTEURS.METIER */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_COLLECTION (
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_EDITEUR (
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_GENRE (
    ID_GENRE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN GENRES.ID_GENRE */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_INITIALE (
    INITIALE T_INITIALE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_SERIE (
    IN_ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_BY_UNIVERS (
    IN_ID_UNIVERS CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN UNIVERS.ID_UNIVERS */,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    TOMEDEBUT SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEDEBUT */,
    TOMEFIN SMALLINT /* TYPE OF COLUMN ALBUMS.TOMEFIN */,
    HORSSERIE SMALLINT /* TYPE OF COLUMN ALBUMS.HORSSERIE */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    NOTATION SMALLINT /* TYPE OF COLUMN ALBUMS.NOTATION */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */,
    ID_UNIVERS CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN UNIVERS.ID_UNIVERS */,
    ID_UNIVERS_RACINE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN UNIVERS.ID_UNIVERS_RACINE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ALBUMS_MANQUANTS (
    WITHINTEGRALE TYPE OF T_YESNO,
    WITHACHAT TYPE OF T_YESNO,
    IN_IDSERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */)
    RETURNS (
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    COUNTSERIE INTEGER,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    NOMCOLLECTION VARCHAR(50) /* TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE ANNEES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    COUNTANNEE INTEGER)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE CALCUL_ANNEE_SORTIE (
    WITHACHAT T_YESNO,
    IN_IDSERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    SOMMEPONDEREE INTEGER,
    COMPTEALBUM INTEGER,
    MAXTOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    MAXANNEE SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    MAXMOIS SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */)
    RETURNS (
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    NOMCOLLECTION VARCHAR(50) /* TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE COLLECTIONS_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    NOMCOLLECTION VARCHAR(50) /* TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION */,
    COUNTCOLLECTION INTEGER,
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE COLLECTIONS_BY_INITIALE (
    INITIALE T_INITIALE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    NOMCOLLECTION VARCHAR(50) /* TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION */,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE DELETEFILE (
    FICHIER VARCHAR(255) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    RESULT INTEGER)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE DIRECTORYCONTENT (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    SEARCHATTR INTEGER)
    RETURNS (
    SEARCHREC INTEGER,
    FILENAME VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    FILESIZE INTEGER,
    FILEATTR INTEGER)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE EDITEURS_ACHATALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    COUNTEDITEUR INTEGER,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE EDITEURS_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    COUNTEDITEUR INTEGER,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE EDITEURS_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE EMPRUNTEURS_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
    ID_EMPRUNTEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EMPRUNTEURS.ID_EMPRUNTEUR */,
    NOMEMPRUNTEUR VARCHAR(150) /* TYPE OF COLUMN EMPRUNTEURS.NOMEMPRUNTEUR */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE GENRES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
    GENRE VARCHAR(30) /* TYPE OF COLUMN GENRES.GENRE */,
    COUNTGENRE INTEGER,
    ID_GENRE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN GENRES.ID_GENRE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE GENRES_BY_INITIALE (
    INITIALE T_INITIALE_UTF8)
    RETURNS (
    ID_GENRE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN GENRES.ID_GENRE */,
    GENRE VARCHAR(30) /* TYPE OF COLUMN GENRES.GENRE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE GET_INITIALE (
    CHAINE T_TITRE_UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
    INITIALE T_INITIALE_UTF8)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE INITIALES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    INITIALETITREALBUM CHAR(1) /* TYPE OF COLUMN ALBUMS.INITIALETITREALBUM */,
    COUNTINITIALE INTEGER)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE INITIALES_COLLECTIONS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    INITIALENOMCOLLECTION CHAR(1) /* TYPE OF COLUMN COLLECTIONS.INITIALENOMCOLLECTION */,
    COUNTINITIALE INTEGER)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE INITIALES_UNIVERS (
    FILTRE VARCHAR(150) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
    INITIALENOMUNIVERS CHAR(1) /* TYPE OF COLUMN UNIVERS.INITIALENOMUNIVERS */,
    COUNTINITIALE INTEGER)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE LISTE_TOMES (
    WITHINTEGRALE T_YESNO,
    IN_IDSERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */)
    RETURNS (
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    INTEGRALE SMALLINT /* TYPE OF COLUMN ALBUMS.INTEGRALE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE LOADBLOBFROMFILE (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    FICHIER VARCHAR(255) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    BLOBCONTENT BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE PARABD_BY_SERIE (
    IN_ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    FILTRE VARCHAR(125) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
    ID_PARABD CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN PARABD.ID_PARABD */,
    TITREPARABD VARCHAR(150) /* TYPE OF COLUMN PARABD.TITREPARABD */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ACHAT SMALLINT /* TYPE OF COLUMN ALBUMS.ACHAT */,
    COMPLET INTEGER /* TYPE OF COLUMN ALBUMS.COMPLET */,
    SCATEGORIE VARCHAR(50) /* TYPE OF COLUMN LISTES.LIBELLE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE PERSONNES_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
    ID_PERSONNE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN PERSONNES.ID_PERSONNE */,
    NOMPERSONNE VARCHAR(150) /* TYPE OF COLUMN PERSONNES.NOMPERSONNE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE PREVISIONS_SORTIES (
    WITHACHAT T_YESNO,
    IN_ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */)
    RETURNS (
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    TERMINEE SMALLINT /* TYPE OF COLUMN SERIES.TERMINEE */,
    TOME SMALLINT /* TYPE OF COLUMN ALBUMS.TOME */,
    ANNEEPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.ANNEEPARUTION */,
    MOISPARUTION SMALLINT /* TYPE OF COLUMN ALBUMS.MOISPARUTION */,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    NOMCOLLECTION VARCHAR(50) /* TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE PROC_AJOUTMVT (
    ID_EDITION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITIONS.ID_EDITION */,
    ID_EMPRUNTEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EMPRUNTEURS.ID_EMPRUNTEUR */,
    DATEEMPRUNT TIMESTAMP,
    PRET SMALLINT /* TYPE OF COLUMN STATUT.PRETEMPRUNT */)
AS
BEGIN
EXIT;
END;





CREATE PROCEDURE PROC_AUTEURS (
    ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    PARABD CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN PARABD.ID_PARABD */)
    RETURNS (
    ID_PERSONNE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN PERSONNES.ID_PERSONNE */,
    NOMPERSONNE VARCHAR(150) /* TYPE OF COLUMN PERSONNES.NOMPERSONNE */,
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    ID_PARABD CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN PARABD.ID_PARABD */,
    METIER SMALLINT /* TYPE OF COLUMN AUTEURS.METIER */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE PROC_EMPRUNTS
    RETURNS (
    ID_EDITION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITIONS.ID_EDITION */,
    ID_ALBUM CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN ALBUMS.ID_ALBUM */,
    TITREALBUM VARCHAR(150) /* TYPE OF COLUMN ALBUMS.TITREALBUM */,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    PRETE SMALLINT /* TYPE OF COLUMN EDITIONS.PRETE */,
    ID_EMPRUNTEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EMPRUNTEURS.ID_EMPRUNTEUR */,
    NOMEMPRUNTEUR VARCHAR(150) /* TYPE OF COLUMN EMPRUNTEURS.NOMEMPRUNTEUR */,
    PRETEMPRUNT SMALLINT /* TYPE OF COLUMN STATUT.PRETEMPRUNT */,
    DATEEMPRUNT TIMESTAMP /* TYPE OF COLUMN STATUT.DATEEMPRUNT */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE SAVEBLOBTOFILE (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    FICHIER VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    BLOBCONTENT BLOB SUB_TYPE 0 SEGMENT SIZE 80)
    RETURNS (
    RESULT INTEGER)
AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE SEARCHFILENAME (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    OLD_FILENAME VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    RESERVE INTEGER)
    RETURNS (
    NEW_FILENAME VARCHAR(255) CHARACTER SET NONE COLLATE NONE)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE SERIES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    COUNTSERIE INTEGER,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE SERIES_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */,
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    ID_EDITEUR CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN EDITEURS.ID_EDITEUR */,
    NOMEDITEUR VARCHAR(50) /* TYPE OF COLUMN EDITEURS.NOMEDITEUR */,
    ID_COLLECTION CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN COLLECTIONS.ID_COLLECTION */,
    NOMCOLLECTION VARCHAR(50) /* TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE SERIES_PARABD (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    TITRESERIE VARCHAR(150) /* TYPE OF COLUMN SERIES.TITRESERIE */,
    COUNTSERIE INTEGER,
    ID_SERIE CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN SERIES.ID_SERIE */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE UNIVERS_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
    NOMUNIVERS VARCHAR(150) /* TYPE OF COLUMN UNIVERS.NOMUNIVERS */,
    COUNTUNIVERS INTEGER,
    ID_UNIVERS CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN UNIVERS.ID_UNIVERS */)
    AS
BEGIN
SUSPEND;
END;





CREATE PROCEDURE UNIVERS_BY_INITIALE (
    INITIALE T_INITIALE_UTF8,
    FILTRE VARCHAR(150) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
    ID_UNIVERS CHAR(38) CHARACTER SET NONE /* TYPE OF COLUMN UNIVERS.ID_UNIVERS */,
    NOMUNIVERS VARCHAR(150) /* TYPE OF COLUMN UNIVERS.NOMUNIVERS */)
    AS
BEGIN
SUSPEND;
END;







/******************************************************************************/
/*                                   Tables                                   */
/******************************************************************************/



CREATE TABLE ALBUMS (
                        ID_ALBUM            T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        MOISPARUTION        SMALLINT,
                        ANNEEPARUTION       SMALLINT,
                        ID_SERIE            T_GUID /* T_GUID = CHAR(38) */,
                        TOME                SMALLINT DEFAULT NULL,
                        TOMEDEBUT           SMALLINT,
                        TOMEFIN             SMALLINT,
                        HORSSERIE           T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        INTEGRALE           T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        ACHAT               T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        NBEDITIONS          INTEGER DEFAULT 0,
                        INITIALETITREALBUM  T_INITIALE_UTF8 /* T_INITIALE_UTF8 = CHAR(1) */,
                        DC_ALBUMS           T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_ALBUMS           T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        TITREALBUM          T_TITRE_UTF8 /* T_TITRE_UTF8 = VARCHAR(150) */,
                        SOUNDEXTITREALBUM   T_SOUNDEX_UTF8 /* T_SOUNDEX_UTF8 = VARCHAR(30) */,
                        NOTATION            SMALLINT,
                        SUJETALBUM          T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                        REMARQUESALBUM      T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                        DS_ALBUMS           TIMESTAMP
);

CREATE TABLE ALBUMS_UNIVERS (
                                ID_ALBUM           T_GUID_NOTNULL NOT NULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_UNIVERS         T_GUID_NOTNULL NOT NULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                SOURCE_ALBUM       T_YESNO_BASENO NOT NULL /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                                SOURCE_SERIE       T_YESNO_BASENO NOT NULL /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                                DC_ALBUMS_UNIVERS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DM_ALBUMS_UNIVERS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                ID_ALBUM_UNIVERS   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                DS_ALBUMS_UNIVERS  TIMESTAMP
);

CREATE TABLE AUTEURS (
                         ID_AUTEUR    T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                         ID_ALBUM     T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                         ID_PERSONNE  T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                         METIER       SMALLINT NOT NULL,
                         DC_AUTEURS   T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                         DM_AUTEURS   T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                         DS_AUTEURS   TIMESTAMP
);

CREATE TABLE AUTEURS_PARABD (
                                ID_AUTEUR_PARABD   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_PARABD          T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_PERSONNE        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                DC_AUTEURS_PARABD  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DM_AUTEURS_PARABD  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DS_AUTEURS_PARABD  TIMESTAMP
);

CREATE TABLE AUTEURS_SERIES (
                                ID_AUTEUR_SERIES   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_SERIE           T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_PERSONNE        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                METIER             SMALLINT NOT NULL,
                                DC_AUTEURS_SERIES  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DM_AUTEURS_SERIES  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DS_AUTEURS_SERIES  TIMESTAMP
);

CREATE TABLE COLLECTIONS (
                             ID_COLLECTION          T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             ID_EDITEUR             T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             INITIALENOMCOLLECTION  T_INITIALE_UTF8 NOT NULL /* T_INITIALE_UTF8 = CHAR(1) */,
                             DC_COLLECTIONS         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             DM_COLLECTIONS         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             NOMCOLLECTION          T_IDENT50_UTF8 /* T_IDENT50_UTF8 = VARCHAR(50) */,
                             DS_COLLECTIONS         TIMESTAMP
);

CREATE TABLE CONVERSIONS (
                             ID_CONVERSION   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             TAUX            NUMERIC(5,5),
                             DC_CONVERSIONS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             DM_CONVERSIONS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             MONNAIE1        VARCHAR(5) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                             MONNAIE2        VARCHAR(5) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                             DS_CONVERSIONS  TIMESTAMP
);

CREATE TABLE COTES (
                       ID_COTE     T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                       ID_EDITION  T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                       ANNEECOTE   SMALLINT NOT NULL,
                       PRIXCOTE    NUMERIC(15,2) NOT NULL,
                       DC_COTES    T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                       DM_COTES    T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                       DS_COTES    TIMESTAMP
);

CREATE TABLE COTES_PARABD (
                              ID_COTE_PARABD   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                              ID_PARABD        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                              ANNEECOTE        SMALLINT NOT NULL,
                              PRIXCOTE         NUMERIC(15,2) NOT NULL,
                              DC_COTES_PARABD  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                              DM_COTES_PARABD  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                              DS_COTES_PARABD  TIMESTAMP
);

CREATE TABLE COUVERTURES (
                             ID_COUVERTURE       T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             ID_ALBUM            T_GUID /* T_GUID = CHAR(38) */,
                             ID_EDITION          T_GUID /* T_GUID = CHAR(38) */,
                             ORDRE               INTEGER,
                             CATEGORIEIMAGE      SMALLINT,
                             STOCKAGECOUVERTURE  SMALLINT,
                             IMAGECOUVERTURE     BLOB SUB_TYPE 0 SEGMENT SIZE 80,
                             DC_COUVERTURES      T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             DM_COUVERTURES      T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             FICHIERCOUVERTURE   VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                             DS_COUVERTURES      TIMESTAMP
);

CREATE TABLE CRITERES (
                          ID_CRITERE    T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                          TYPE_CRITERE  VARCHAR(20) CHARACTER SET NONE COLLATE NONE,
                          REFCRITERE    T_REFNOTNULL /* T_REFNOTNULL = INTEGER DEFAULT NULL NOT NULL */,
                          DC_CRITERE    T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                          DM_CRITERE    T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                          CRITERE       VARCHAR(20) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI
);

CREATE TABLE EDITEURS (
                          ID_EDITEUR          T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                          INITIALENOMEDITEUR  T_INITIALE_UTF8 NOT NULL /* T_INITIALE_UTF8 = CHAR(1) */,
                          DC_EDITEURS         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                          DM_EDITEURS         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                          NOMEDITEUR          T_IDENT50_UTF8 /* T_IDENT50_UTF8 = VARCHAR(50) */,
                          SITEWEB             VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                          DS_EDITEURS         TIMESTAMP
);

CREATE TABLE EDITIONS (
                          ID_EDITION     T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                          ID_ALBUM       T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                          ID_EDITEUR     T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                          ID_COLLECTION  T_GUID /* T_GUID = CHAR(38) */,
                          ANNEEEDITION   SMALLINT,
                          PRIX           NUMERIC(15,2),
                          VO             T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          COULEUR        T_YESNO_BASEYES /* T_YESNO_BASEYES = SMALLINT DEFAULT 1 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          PRETE          T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          STOCK          T_YESNO_BASEYES /* T_YESNO_BASEYES = SMALLINT DEFAULT 1 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          DEDICACE       T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          ETAT           INTEGER,
                          RELIURE        INTEGER,
                          TYPEEDITION    INTEGER,
                          DATEACHAT      DATE,
                          GRATUIT        T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          OFFERT         T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                          NOMBREDEPAGES  INTEGER,
                          ORIENTATION    SMALLINT,
                          FORMATEDITION  SMALLINT,
                          ANNEECOTE      SMALLINT,
                          PRIXCOTE       NUMERIC(15,2),
                          DC_EDITIONS    T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                          DM_EDITIONS    T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                          SENSLECTURE    SMALLINT,
                          ISBN           CHAR(13) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                          NUMEROPERSO    VARCHAR(25) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                          NOTES          T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                          DS_EDITIONS    TIMESTAMP,
                          OCCASION       T_YESNO /* T_YESNO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */
);

CREATE TABLE EMPRUNTEURS (
                             ID_EMPRUNTEUR          T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             INITIALENOMEMPRUNTEUR  T_INITIALE_UTF8 /* T_INITIALE_UTF8 = CHAR(1) */,
                             DC_EMPRUNTEURS         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             DM_EMPRUNTEURS         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             NOMEMPRUNTEUR          T_NOM_UTF8 /* T_NOM_UTF8 = VARCHAR(150) */,
                             ADRESSEEMPRUNTEUR      T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                             DS_EMPRUNTEURS         TIMESTAMP
);

CREATE TABLE GENRES (
                        ID_GENRE       T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        DC_GENRES      T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_GENRES      T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        INITIALEGENRE  T_INITIALE_UTF8 /* T_INITIALE_UTF8 = CHAR(1) */,
                        GENRE          VARCHAR(30) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                        DS_GENRES      TIMESTAMP
);

CREATE TABLE GENRESERIES (
                             ID_GENRESERIES  T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             ID_SERIE        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             ID_GENRE        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                             DC_GENRESERIES  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             DM_GENRESERIES  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                             DS_GENRESERIES  TIMESTAMP
);

CREATE TABLE IMPORT_ASSOCIATIONS (
                                     ID        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                     PARENTID  T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                     TYPEDATA  SMALLINT NOT NULL,
                                     ALWAYS    T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                                     CHAINE    VARCHAR(100) CHARACTER SET UTF8 NOT NULL COLLATE UTF8_FR_CI_AI
);

CREATE TABLE LISTES (
                        ID_LISTE   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        REF        INTEGER NOT NULL,
                        CATEGORIE  INTEGER NOT NULL,
                        ORDRE      INTEGER,
                        DEFAUT     T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        DC_LISTES  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_LISTES  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        LIBELLE    VARCHAR(50) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                        DS_LISTES  TIMESTAMP
);

CREATE TABLE OPTIONS (
                         ID_OPTION   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                         DC_OPTIONS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                         DM_OPTIONS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                         VALEUR      VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                         NOM_OPTION  VARCHAR(15) CHARACTER SET UTF8 NOT NULL COLLATE UTF8_FR_CI_AI,
                         DS_OPTIONS  TIMESTAMP
);

CREATE TABLE OPTIONS_SCRIPTS (
                                 ID_OPTION           T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                 DC_OPTIONS_SCRIPTS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                 DM_OPTIONS_SCRIPTS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                 VALEUR              VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                                 NOM_OPTION          VARCHAR(50) CHARACTER SET UTF8 NOT NULL COLLATE UTF8_FR_CI_AI,
                                 SCRIPT              VARCHAR(50) CHARACTER SET UTF8 NOT NULL COLLATE UTF8_FR_CI_AI,
                                 DS_OPTIONS_SCRIPTS  TIMESTAMP
);

CREATE TABLE PARABD (
                        ID_PARABD            T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        ID_SERIE             T_GUID /* T_GUID = CHAR(38) */,
                        CATEGORIEPARABD      SMALLINT,
                        ACHAT                T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        COMPLET              INTEGER,
                        DEDICACE             T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        NUMEROTE             T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        ANNEE                SMALLINT,
                        ANNEECOTE            SMALLINT,
                        PRIXCOTE             NUMERIC(15,2),
                        PRETE                T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        STOCK                T_YESNO_BASEYES /* T_YESNO_BASEYES = SMALLINT DEFAULT 1 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        DATEACHAT            DATE,
                        PRIX                 NUMERIC(15,2),
                        GRATUIT              T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        OFFERT               T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        INITIALETITREPARABD  T_INITIALE_UTF8 /* T_INITIALE_UTF8 = CHAR(1) */,
                        DC_PARABD            T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_PARABD            T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        TITREPARABD          T_TITRE_UTF8 /* T_TITRE_UTF8 = VARCHAR(150) */,
                        SOUNDEXTITREPARABD   T_SOUNDEX_UTF8 /* T_SOUNDEX_UTF8 = VARCHAR(30) */,
                        DESCRIPTION          T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                        DS_PARABD            TIMESTAMP,
                        NOTES                T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */
);

CREATE TABLE PARABD_UNIVERS (
                                ID_PARABD          T_GUID_NOTNULL NOT NULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_UNIVERS         T_GUID_NOTNULL NOT NULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                SOURCE_PARABD      T_YESNO_BASENO NOT NULL /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                                SOURCE_SERIE       T_YESNO_BASENO NOT NULL /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                                DC_PARABD_UNIVERS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DM_PARABD_UNIVERS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                ID_PARABD_UNIVERS  T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                DS_PARABD_UNIVERS  TIMESTAMP
);

CREATE TABLE PERSONNES (
                           ID_PERSONNE          T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                           INITIALENOMPERSONNE  T_INITIALE_UTF8 /* T_INITIALE_UTF8 = CHAR(1) */,
                           DC_PERSONNES         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                           DM_PERSONNES         T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                           NOMPERSONNE          T_TITRE_UTF8 /* T_TITRE_UTF8 = VARCHAR(150) */,
                           SITEWEB              VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                           BIOGRAPHIE           T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                           DS_PERSONNES         TIMESTAMP
);

CREATE TABLE PHOTOS (
                        ID_PHOTO        T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        ID_PARABD       T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        ORDRE           INTEGER,
                        STOCKAGEPHOTO   SMALLINT,
                        IMAGEPHOTO      BLOB SUB_TYPE 0 SEGMENT SIZE 80,
                        DC_PHOTOS       T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_PHOTOS       T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        FICHIERPHOTO    VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                        DS_PHOTOS       TIMESTAMP,
                        CATEGORIEIMAGE  SMALLINT
);

CREATE TABLE SERIES (
                        ID_SERIE            T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        ID_EDITEUR          T_GUID NOT NULL /* T_GUID = CHAR(38) */,
                        ID_COLLECTION       T_GUID /* T_GUID = CHAR(38) */,
                        TERMINEE            T_YESNO /* T_YESNO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        COMPLETE            T_YESNO_BASENO /* T_YESNO_BASENO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        SUIVREMANQUANTS     T_YESNO_BASEYES /* T_YESNO_BASEYES = SMALLINT DEFAULT 1 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        SUIVRESORTIES       T_YESNO_BASEYES /* T_YESNO_BASEYES = SMALLINT DEFAULT 1 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        INITIALETITRESERIE  T_INITIALE_UTF8 NOT NULL /* T_INITIALE_UTF8 = CHAR(1) */,
                        DC_SERIES           T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_SERIES           T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        NB_ALBUMS           INTEGER,
                        ETAT                INTEGER,
                        RELIURE             INTEGER,
                        TYPEEDITION         INTEGER,
                        ORIENTATION         INTEGER,
                        FORMATEDITION       INTEGER,
                        SENSLECTURE         INTEGER,
                        VO                  T_YESNO /* T_YESNO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        COULEUR             T_YESNO /* T_YESNO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        TITRESERIE          T_TITRE_UTF8 /* T_TITRE_UTF8 = VARCHAR(150) */,
                        SOUNDEXTITRESERIE   T_SOUNDEX_UTF8 /* T_SOUNDEX_UTF8 = VARCHAR(30) */,
                        NOTATION            SMALLINT,
                        SITEWEB             VARCHAR(255) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI,
                        SUJETSERIE          T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                        REMARQUESSERIE      T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                        DS_SERIES           TIMESTAMP
);

CREATE TABLE SERIES_UNIVERS (
                                ID_SERIE           T_GUID_NOTNULL NOT NULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                ID_UNIVERS         T_GUID_NOTNULL NOT NULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                DC_SERIES_UNIVERS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                DM_SERIES_UNIVERS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                                ID_SERIE_UNIVERS   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                                DS_SERIES_UNIVERS  TIMESTAMP
);

CREATE TABLE STATUT (
                        ID_STATUT      T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        DATEEMPRUNT    TIMESTAMP NOT NULL,
                        ID_EDITION     T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        PRETEMPRUNT    T_YESNO NOT NULL /* T_YESNO = SMALLINT DEFAULT 0 CHECK ((VALUE IS NULL) OR (VALUE between 0 and 1)) */,
                        ID_EMPRUNTEUR  T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                        DC_STATUT      T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DM_STATUT      T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                        DS_STATUT      TIMESTAMP
);

CREATE TABLE SUPPRESSIONS (
                              ID_SUPPRESSION   T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                              TABLENAME        CHAR(31) CHARACTER SET UNICODE_FSS,
                              FIELDNAME        CHAR(31) CHARACTER SET UNICODE_FSS,
                              ID               T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                              DC_SUPPRESSIONS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                              DM_SUPPRESSIONS  T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */
);

CREATE TABLE UNIVERS (
                         ID_UNIVERS          T_GUID_NOTNULL /* T_GUID_NOTNULL = CHAR(38) NOT NULL */,
                         NOMUNIVERS          T_NOM_UTF8 NOT NULL /* T_NOM_UTF8 = VARCHAR(150) */,
                         DESCRIPTION         T_DESCRIPTION_UTF8 /* T_DESCRIPTION_UTF8 = BLOB SUB_TYPE 1 SEGMENT SIZE 80 */,
                         INITIALENOMUNIVERS  T_INITIALE_UTF8 /* T_INITIALE_UTF8 = CHAR(1) */,
                         SITEWEB             T_SITEWEB /* T_SITEWEB = VARCHAR(255) */,
                         ID_UNIVERS_PARENT   T_GUID /* T_GUID = CHAR(38) */,
                         ID_UNIVERS_RACINE   T_GUID /* T_GUID = CHAR(38) */,
                         DC_UNIVERS          T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                         DM_UNIVERS          T_TIMESTAMP_NOTNULL /* T_TIMESTAMP_NOTNULL = TIMESTAMP NOT NULL */,
                         BRANCHE_UNIVERS     VARCHAR(2000) CHARACTER SET NONE NOT NULL COLLATE NONE,
                         DS_UNIVERS          TIMESTAMP
);



/******************************************************************************/
/*                                   Views                                    */
/******************************************************************************/


/* View: VW_DERNIERES_MODIFS */
CREATE VIEW VW_DERNIERES_MODIFS(
                                TYPEDATA,
                                DATE_CREATION,
                                DATE_MODIF,
                                ID,
                                TITREALBUM,
                                TOME,
                                TOMEDEBUT,
                                TOMEFIN,
                                INTEGRALE,
                                HORSSERIE,
                                TITRESERIE,
                                NOMEDITEUR,
                                NOMCOLLECTION,
                                NOMPERSONNE)
AS
select
    'A', a.dc_albums, a.dm_albums, a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.integrale, a.horsserie,
    s.titreserie, null, null, null
from
    albums a
        left join series s on a.id_serie = s.id_serie

union

select
    'S', s.dc_series, s.dm_series, s.id_serie, null, null, null, null, null, null, s.titreserie, e.nomediteur,
    c.nomcollection, null
from
    series s
        left join editeurs e on e.id_editeur = s.id_editeur
        left join collections c on c.id_collection = s.id_collection

union

select
    'P', p.dc_personnes, p.dm_personnes, p.id_personne, null, null, null, null, null, null, null, null, null,
    p.nompersonne
from
    personnes p
;
;


ALTER TABLE ALBUMS ADD COMPLET COMPUTED BY (case when NBEDITIONS > 0 then 1 else 0 end);

/* View: VW_LISTE_ALBUMS */
CREATE VIEW VW_LISTE_ALBUMS(
                            ID_ALBUM,
                            TITREALBUM,
                            TOME,
                            TOMEDEBUT,
                            TOMEFIN,
                            HORSSERIE,
                            INTEGRALE,
                            MOISPARUTION,
                            ANNEEPARUTION,
                            ID_SERIE,
                            TITRESERIE,
                            ACHAT,
                            COMPLET,
                            NOTATION,
                            INITIALETITREALBUM,
                            INITIALETITRESERIE)
AS
select
    a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie, a.integrale, a.moisparution, a.anneeparution,
    a.id_serie, s.titreserie, a.achat, a.complet, a.notation, coalesce(a.initialetitrealbum, s.initialetitreserie),
    s.initialetitreserie
from
    albums a
        left join series s on
            s.id_serie = a.id_serie
;
;



/* View: VW_EMPRUNTS */
CREATE VIEW VW_EMPRUNTS(
                        ID_STATUT,
                        ID_EDITION,
                        ID_ALBUM,
                        TITREALBUM,
                        ID_SERIE,
                        TOME,
                        INTEGRALE,
                        TOMEDEBUT,
                        TOMEFIN,
                        HORSSERIE,
                        NOTATION,
                        TITRESERIE,
                        ID_EDITEUR,
                        NOMEDITEUR,
                        ID_COLLECTION,
                        NOMCOLLECTION,
                        PRETE,
                        ANNEEEDITION,
                        ISBN,
                        ID_EMPRUNTEUR,
                        NOMEMPRUNTEUR,
                        PRETEMPRUNT,
                        DATEEMPRUNT)
AS
select
    s.id_statut, ed.id_edition, a.id_album, a.titrealbum, a.id_serie, a.tome, a.integrale, a.tomedebut, a.tomefin,
    a.horsserie, a.notation, a.titreserie, e.id_editeur, e.nomediteur, c.id_collection, c.nomcollection, ed.prete,
    ed.anneeedition, ed.isbn, em.id_emprunteur, em.nomemprunteur, s.pretemprunt, s.dateemprunt
from
    vw_liste_albums a
        inner join editions ed on a.id_album = ed.id_album
        inner join editeurs e on e.id_editeur = ed.id_editeur
        left join collections c on c.id_collection = ed.id_collection
        inner join statut s on ed.id_edition = s.id_edition
        inner join emprunteurs em on em.id_emprunteur = s.id_emprunteur
;
;



/* View: VW_INITIALES_EDITEURS */
CREATE VIEW VW_INITIALES_EDITEURS(
                                  INITIALENOMEDITEUR,
                                  COUNTINITIALE)
AS
select
    initialenomediteur, count(id_editeur)
from
    editeurs
group by
    initialenomediteur
;
;



/* View: VW_INITIALES_EMPRUNTEURS */
CREATE VIEW VW_INITIALES_EMPRUNTEURS(
                                     INITIALENOMEMPRUNTEUR,
                                     COUNTINITIALE)
AS
select
    initialenomemprunteur, count(id_emprunteur)
from
    emprunteurs
group by
    initialenomemprunteur
;
;



/* View: VW_INITIALES_GENRES */
CREATE VIEW VW_INITIALES_GENRES(
                                INITIALEGENRE,
                                COUNTINITIALE)
AS
select
    initialegenre, count(id_genre)
from
    genres
group by
    initialegenre
;
;



/* View: VW_INITIALES_PERSONNES */
CREATE VIEW VW_INITIALES_PERSONNES(
                                   INITIALENOMPERSONNE,
                                   COUNTINITIALE)
AS
select
    initialenompersonne, count(id_personne)
from
    personnes
group by
    initialenompersonne
;
;



/* View: VW_INITIALES_SERIES */
CREATE VIEW VW_INITIALES_SERIES(
                                INITIALETITRESERIE,
                                COUNTINITIALE)
AS
select
    initialetitreserie, count(id_serie)
from
    series
group by
    initialetitreserie
;
;



/* View: VW_LISTE_ALBUMS_UNIVERS */
CREATE VIEW VW_LISTE_ALBUMS_UNIVERS(
                                    ID_ALBUM,
                                    TITREALBUM,
                                    TOME,
                                    TOMEDEBUT,
                                    TOMEFIN,
                                    HORSSERIE,
                                    INTEGRALE,
                                    MOISPARUTION,
                                    ANNEEPARUTION,
                                    ID_SERIE,
                                    TITRESERIE,
                                    ACHAT,
                                    COMPLET,
                                    NOTATION,
                                    INITIALETITREALBUM,
                                    INITIALETITRESERIE,
                                    ID_UNIVERS,
                                    NOMUNIVERS,
                                    ID_UNIVERS_RACINE,
                                    ID_UNIVERS_PARENT,
                                    BRANCHE_UNIVERS)
AS
select
    a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie, a.integrale, a.moisparution, a.anneeparution,
    a.id_serie, s.titreserie, a.achat, a.complet, a.notation, coalesce(a.initialetitrealbum, s.initialetitreserie),
    s.initialetitreserie, au.id_univers, u.nomunivers, u.id_univers_racine, u.id_univers_parent, u.branche_univers
from
    albums a
        left join series s on
            s.id_serie = a.id_serie
        left join albums_univers au on
            au.id_album = a.id_album
        left join univers u on
            u.id_univers = au.id_univers
;
;



/* View: VW_LISTE_COLLECTIONS */
CREATE VIEW VW_LISTE_COLLECTIONS(
                                 ID_COLLECTION,
                                 NOMCOLLECTION,
                                 INITIALENOMCOLLECTION,
                                 ID_EDITEUR,
                                 NOMEDITEUR)
AS
select
    c.id_collection, c.nomcollection, c.initialenomcollection, e.id_editeur, e.nomediteur
from
    collections c
        inner join editeurs e on e.id_editeur = c.id_editeur
;
;



/* View: VW_LISTE_COLLECTIONS_ALBUMS */
CREATE VIEW VW_LISTE_COLLECTIONS_ALBUMS(
                                        ID_ALBUM,
                                        TITREALBUM,
                                        TOME,
                                        TOMEDEBUT,
                                        TOMEFIN,
                                        HORSSERIE,
                                        INTEGRALE,
                                        MOISPARUTION,
                                        ANNEEPARUTION,
                                        NOTATION,
                                        ID_SERIE,
                                        TITRESERIE,
                                        ID_EDITEUR,
                                        NOMEDITEUR,
                                        ID_COLLECTION,
                                        NOMCOLLECTION,
                                        ACHAT,
                                        COMPLET)
AS
select
    a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie, a.integrale, a.moisparution, a.anneeparution,
    a.notation, a.id_serie, a.titreserie, e.id_editeur, e.nomediteur, c.id_collection, c.nomcollection, a.achat,
    a.complet
from
    vw_liste_albums a
        left join editions ed on ed.id_album = a.id_album
        left join collections c on ed.id_collection = c.id_collection
        left join editeurs e on e.id_editeur = ed.id_editeur
;
;



/* View: VW_LISTE_EDITEURS_ACHATALBUMS */
CREATE VIEW VW_LISTE_EDITEURS_ACHATALBUMS(
                                          ID_ALBUM,
                                          TITREALBUM,
                                          TOME,
                                          TOMEDEBUT,
                                          TOMEFIN,
                                          HORSSERIE,
                                          INTEGRALE,
                                          MOISPARUTION,
                                          ANNEEPARUTION,
                                          NOTATION,
                                          ID_SERIE,
                                          TITRESERIE,
                                          ID_EDITEUR,
                                          NOMEDITEUR,
                                          ACHAT,
                                          COMPLET)
AS
select
    a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie, a.integrale, a.moisparution, a.anneeparution,
    a.notation, a.id_serie, a.titreserie, e.id_editeur, e.nomediteur, a.achat, a.complet
from
    vw_liste_albums a
        left join series s on s.id_serie = a.id_serie
        left join editeurs e on e.id_editeur = s.id_editeur
;
;



/* View: VW_LISTE_EDITEURS_ALBUMS */
CREATE VIEW VW_LISTE_EDITEURS_ALBUMS(
                                     ID_ALBUM,
                                     TITREALBUM,
                                     TOME,
                                     TOMEDEBUT,
                                     TOMEFIN,
                                     HORSSERIE,
                                     INTEGRALE,
                                     MOISPARUTION,
                                     ANNEEPARUTION,
                                     NOTATION,
                                     ID_SERIE,
                                     TITRESERIE,
                                     ID_EDITEUR,
                                     NOMEDITEUR,
                                     ACHAT,
                                     COMPLET)
AS
select
    a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie, a.integrale, a.moisparution, a.anneeparution,
    a.notation, a.id_serie, a.titreserie, e.id_editeur, e.nomediteur, a.achat, a.complet
from
    vw_liste_albums a
        left join editions ed on ed.id_album = a.id_album
        left join editeurs e on e.id_editeur = ed.id_editeur
;
;



/* View: VW_LISTE_GENRES_ALBUMS */
CREATE VIEW VW_LISTE_GENRES_ALBUMS(
                                   ID_ALBUM,
                                   TITREALBUM,
                                   TOME,
                                   TOMEDEBUT,
                                   TOMEFIN,
                                   HORSSERIE,
                                   INTEGRALE,
                                   MOISPARUTION,
                                   ANNEEPARUTION,
                                   NOTATION,
                                   ID_SERIE,
                                   TITRESERIE,
                                   ID_GENRE,
                                   GENRE,
                                   ACHAT,
                                   COMPLET)
AS
select
    a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie, a.integrale, a.moisparution, a.anneeparution,
    a.notation, a.id_serie, a.titreserie, g.id_genre, g.genre, a.achat, a.complet
from
    vw_liste_albums a
        left join genreseries gs on gs.id_serie = a.id_serie
        left join genres g on gs.id_genre = g.id_genre
;
;



/* View: VW_LISTE_PARABD */
CREATE VIEW VW_LISTE_PARABD(
                            ID_PARABD,
                            TITREPARABD,
                            ID_SERIE,
                            TITRESERIE,
                            ACHAT,
                            COMPLET,
                            SCATEGORIE)
AS
select
    p.id_parabd, p.titreparabd, p.id_serie, s.titreserie, p.achat, p.complet, lc.libelle
from
    parabd p
        left join series s on
            s.id_serie = p.id_serie
        left join listes lc on
                lc.ref = p.categorieparabd and lc.categorie = 7
;
;



/* View: VW_LISTE_PARABD_UNIVERS */
CREATE VIEW VW_LISTE_PARABD_UNIVERS(
                                    ID_PARABD,
                                    TITREPARABD,
                                    ID_SERIE,
                                    TITRESERIE,
                                    ACHAT,
                                    COMPLET,
                                    SCATEGORIE,
                                    ID_UNIVERS,
                                    NOMUNIVERS,
                                    ID_UNIVERS_RACINE,
                                    ID_UNIVERS_PARENT,
                                    BRANCHE_UNIVERS)
AS
select
    p.id_parabd, p.titreparabd, p.id_serie, s.titreserie, p.achat, p.complet, lc.libelle,
    pu.id_univers, u.nomunivers, u.id_univers_racine, u.id_univers_parent, u.branche_univers
from
    parabd p
        left join series s on
            s.id_serie = p.id_serie
        left join listes lc on
                lc.ref = p.categorieparabd and lc.categorie = 7
        left join parabd_univers pu on
            pu.id_parabd = p.id_parabd
        left join univers u on
            u.id_univers = pu.id_univers
;
;



/* View: VW_PRIXALBUMS */
CREATE VIEW VW_PRIXALBUMS(
                          ID_ALBUM,
                          HORSSERIE,
                          TOME,
                          INTEGRALE,
                          TOMEDEBUT,
                          TOMEFIN,
                          NBALBUMS,
                          ID_SERIE,
                          ID_EDITION,
                          ID_EDITEUR,
                          PRIX)
AS
select
    a.id_album,
    a.horsserie,
    a.tome,
    a.integrale,
    a.tomedebut,
    a.tomefin,
    case
        when a.integrale = 0 then 1
        when a.tomedebut is null then 1
        when a.tomefin is null then 1
        when a.tomefin < a.tomedebut then 1
        else a.tomefin - a.tomedebut + 1
        end as nbalbums,
    a.id_serie,
    e.id_edition,
    e.id_editeur,
    e.prix
from albums a
         inner join editions e on a.id_album = e.id_album
;
;



/* View: VW_PRIXUNITAIRES */
CREATE VIEW VW_PRIXUNITAIRES(
                             HORSSERIE,
                             ID_SERIE,
                             ID_EDITEUR,
                             PRIXUNITAIRE)
AS
select
    horsserie, id_serie, id_editeur,
    avg(prix / nbalbums) as prixunitaire
from vw_prixalbums
where
    prix is not null
group by
    id_serie,
    horsserie,
    id_editeur
;
;








/******************************************************************************/
/*                             Unique constraints                             */
/******************************************************************************/

ALTER TABLE ALBUMS_UNIVERS ADD CONSTRAINT UNQ1_ALBUMS_UNIVERS UNIQUE (ID_ALBUM_UNIVERS);
ALTER TABLE AUTEURS ADD CONSTRAINT AUTEURS_UNQID UNIQUE (ID_AUTEUR);
ALTER TABLE AUTEURS_PARABD ADD CONSTRAINT AUTEURS_PARABD_UNQID UNIQUE (ID_AUTEUR_PARABD);
ALTER TABLE AUTEURS_SERIES ADD CONSTRAINT AUTEURS_SERIES_UNQID UNIQUE (ID_AUTEUR_SERIES);
ALTER TABLE CONVERSIONS ADD CONSTRAINT CONVERSIONS_UNQID UNIQUE (ID_CONVERSION);
ALTER TABLE COTES ADD CONSTRAINT COTES_UNQID UNIQUE (ID_COTE);
ALTER TABLE COTES_PARABD ADD CONSTRAINT COTES_PARABD_UNQID UNIQUE (ID_COTE_PARABD);
ALTER TABLE GENRESERIES ADD CONSTRAINT GENRESERIES_UNQID UNIQUE (ID_GENRESERIES);
ALTER TABLE LISTES ADD CONSTRAINT LISTES_UNQID UNIQUE (ID_LISTE);
ALTER TABLE OPTIONS ADD CONSTRAINT OPTIONS_UNQID UNIQUE (ID_OPTION);
ALTER TABLE OPTIONS_SCRIPTS ADD CONSTRAINT OPTIONS_SCRIPTS_UNQID UNIQUE (ID_OPTION);
ALTER TABLE PARABD_UNIVERS ADD CONSTRAINT UNQ1_PARABD_UNIVERS UNIQUE (ID_PARABD_UNIVERS);
ALTER TABLE SERIES_UNIVERS ADD CONSTRAINT UNQ1_SERIES_UNIVERS UNIQUE (ID_SERIE_UNIVERS);


/******************************************************************************/
/*                                Primary keys                                */
/******************************************************************************/

ALTER TABLE ALBUMS ADD CONSTRAINT ALBUMS_PK PRIMARY KEY (ID_ALBUM);
ALTER TABLE ALBUMS_UNIVERS ADD CONSTRAINT PK_ALBUMS_UNIVERS PRIMARY KEY (ID_ALBUM, ID_UNIVERS);
ALTER TABLE AUTEURS ADD CONSTRAINT AUTEURS_PK PRIMARY KEY (ID_ALBUM, ID_PERSONNE, METIER);
ALTER TABLE AUTEURS_PARABD ADD CONSTRAINT AUTEURS_PARABD_PK PRIMARY KEY (ID_PARABD, ID_PERSONNE);
ALTER TABLE AUTEURS_SERIES ADD CONSTRAINT AUTEURS_SERIES_PK PRIMARY KEY (ID_SERIE, ID_PERSONNE, METIER);
ALTER TABLE COLLECTIONS ADD CONSTRAINT COLLECTIONS_PK PRIMARY KEY (ID_COLLECTION);
ALTER TABLE COTES ADD CONSTRAINT COTES_PK PRIMARY KEY (ANNEECOTE, ID_EDITION);
ALTER TABLE COTES_PARABD ADD CONSTRAINT COTES_PARABD_PK PRIMARY KEY (ANNEECOTE, ID_PARABD);
ALTER TABLE COUVERTURES ADD CONSTRAINT COUVERTURES_PK PRIMARY KEY (ID_COUVERTURE);
ALTER TABLE EDITEURS ADD CONSTRAINT EDITEURS_PK PRIMARY KEY (ID_EDITEUR);
ALTER TABLE EDITIONS ADD CONSTRAINT EDITIONS_PK PRIMARY KEY (ID_EDITION);
ALTER TABLE EMPRUNTEURS ADD CONSTRAINT EMPRUNTEURS_PK PRIMARY KEY (ID_EMPRUNTEUR);
ALTER TABLE GENRES ADD CONSTRAINT GENRES_PK PRIMARY KEY (ID_GENRE);
ALTER TABLE GENRESERIES ADD CONSTRAINT GENRESERIES_PK PRIMARY KEY (ID_SERIE, ID_GENRE);
ALTER TABLE IMPORT_ASSOCIATIONS ADD CONSTRAINT PK_IMPORT_ASSOCIATIONS PRIMARY KEY (CHAINE, TYPEDATA, PARENTID);
ALTER TABLE LISTES ADD CONSTRAINT LISTES_PK PRIMARY KEY (CATEGORIE, REF);
ALTER TABLE OPTIONS ADD CONSTRAINT OPTIONS_PK PRIMARY KEY (NOM_OPTION);
ALTER TABLE OPTIONS_SCRIPTS ADD CONSTRAINT OPTIONS_SCRIPTS_PK PRIMARY KEY (SCRIPT, NOM_OPTION);
ALTER TABLE PARABD ADD CONSTRAINT PARABD_PK PRIMARY KEY (ID_PARABD);
ALTER TABLE PARABD_UNIVERS ADD CONSTRAINT PK_PARABD_UNIVERS PRIMARY KEY (ID_PARABD, ID_UNIVERS);
ALTER TABLE PERSONNES ADD CONSTRAINT PERSONNES_PK PRIMARY KEY (ID_PERSONNE);
ALTER TABLE PHOTOS ADD CONSTRAINT PHOTOS_PK PRIMARY KEY (ID_PHOTO);
ALTER TABLE SERIES ADD CONSTRAINT SERIES_PK PRIMARY KEY (ID_SERIE);
ALTER TABLE SERIES_UNIVERS ADD CONSTRAINT PK_SERIES_UNIVERS PRIMARY KEY (ID_SERIE, ID_UNIVERS);
ALTER TABLE STATUT ADD CONSTRAINT STATUT_PK PRIMARY KEY (ID_STATUT);
ALTER TABLE SUPPRESSIONS ADD CONSTRAINT PK_SUPPRESSIONS PRIMARY KEY (ID_SUPPRESSION);
ALTER TABLE UNIVERS ADD CONSTRAINT PK_UNIVERS PRIMARY KEY (ID_UNIVERS);


/******************************************************************************/
/*                                Foreign keys                                */
/******************************************************************************/

ALTER TABLE ALBUMS_UNIVERS ADD CONSTRAINT FK_ALBUMS_UNIVERS_1 FOREIGN KEY (ID_ALBUM) REFERENCES ALBUMS (ID_ALBUM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE ALBUMS_UNIVERS ADD CONSTRAINT FK_ALBUMS_UNIVERS_2 FOREIGN KEY (ID_UNIVERS) REFERENCES UNIVERS (ID_UNIVERS) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AUTEURS ADD CONSTRAINT AUTEURS_FK1 FOREIGN KEY (ID_ALBUM) REFERENCES ALBUMS (ID_ALBUM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AUTEURS ADD CONSTRAINT AUTEURS_FK2 FOREIGN KEY (ID_PERSONNE) REFERENCES PERSONNES (ID_PERSONNE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AUTEURS_PARABD ADD CONSTRAINT AUTEURS_PARABD_FK1 FOREIGN KEY (ID_PARABD) REFERENCES PARABD (ID_PARABD) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AUTEURS_PARABD ADD CONSTRAINT AUTEURS_PARABD_FK2 FOREIGN KEY (ID_PERSONNE) REFERENCES PERSONNES (ID_PERSONNE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AUTEURS_SERIES ADD CONSTRAINT AUTEURS_SERIES_FK1 FOREIGN KEY (ID_SERIE) REFERENCES SERIES (ID_SERIE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AUTEURS_SERIES ADD CONSTRAINT AUTEURS_SERIES_FK2 FOREIGN KEY (ID_PERSONNE) REFERENCES PERSONNES (ID_PERSONNE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE COLLECTIONS ADD CONSTRAINT COLLECTIONS_FK1 FOREIGN KEY (ID_EDITEUR) REFERENCES EDITEURS (ID_EDITEUR) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE COTES ADD CONSTRAINT COTES_FK1 FOREIGN KEY (ID_EDITION) REFERENCES EDITIONS (ID_EDITION) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE COTES_PARABD ADD CONSTRAINT COTES_PARABD_FK1 FOREIGN KEY (ID_PARABD) REFERENCES PARABD (ID_PARABD) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE COUVERTURES ADD CONSTRAINT COUVERTURES_FK1 FOREIGN KEY (ID_ALBUM) REFERENCES ALBUMS (ID_ALBUM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE EDITIONS ADD CONSTRAINT EDITIONS_FK1 FOREIGN KEY (ID_EDITEUR) REFERENCES EDITEURS (ID_EDITEUR) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE EDITIONS ADD CONSTRAINT EDITIONS_FK2 FOREIGN KEY (ID_ALBUM) REFERENCES ALBUMS (ID_ALBUM) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE GENRESERIES ADD CONSTRAINT GENRESERIES_FK1 FOREIGN KEY (ID_GENRE) REFERENCES GENRES (ID_GENRE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE GENRESERIES ADD CONSTRAINT GENRESERIES_FK2 FOREIGN KEY (ID_SERIE) REFERENCES SERIES (ID_SERIE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PARABD_UNIVERS ADD CONSTRAINT FK_PARABD_UNIVERS_1 FOREIGN KEY (ID_PARABD) REFERENCES PARABD (ID_PARABD) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PARABD_UNIVERS ADD CONSTRAINT FK_PARABD_UNIVERS_2 FOREIGN KEY (ID_UNIVERS) REFERENCES UNIVERS (ID_UNIVERS) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PHOTOS ADD CONSTRAINT PHOTOS_FK1 FOREIGN KEY (ID_PARABD) REFERENCES PARABD (ID_PARABD) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SERIES_UNIVERS ADD CONSTRAINT FK_SERIES_UNIVERS_1 FOREIGN KEY (ID_SERIE) REFERENCES SERIES (ID_SERIE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SERIES_UNIVERS ADD CONSTRAINT FK_SERIES_UNIVERS_2 FOREIGN KEY (ID_UNIVERS) REFERENCES UNIVERS (ID_UNIVERS) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE STATUT ADD CONSTRAINT STATUT_FK1 FOREIGN KEY (ID_EDITION) REFERENCES EDITIONS (ID_EDITION) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE STATUT ADD CONSTRAINT STATUT_FK2 FOREIGN KEY (ID_EMPRUNTEUR) REFERENCES EMPRUNTEURS (ID_EMPRUNTEUR) ON DELETE CASCADE ON UPDATE CASCADE;


/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/

CREATE INDEX ALBUMS_IDX1 ON ALBUMS (ANNEEPARUTION, ID_ALBUM);
CREATE INDEX ALBUMS_IDX2 ON ALBUMS (INITIALETITREALBUM, ID_ALBUM);
CREATE INDEX ALBUMS_IDX3 ON ALBUMS (TITREALBUM);
CREATE INDEX ALBUMS_IDX4 ON ALBUMS (HORSSERIE, INTEGRALE, ID_SERIE, ACHAT, ID_ALBUM);
CREATE INDEX ALBUMS_IDX5 ON ALBUMS (TOME, HORSSERIE, INTEGRALE, ID_SERIE);
CREATE INDEX ALBUMS_IDX6 ON ALBUMS (TOMEDEBUT, TOMEFIN, HORSSERIE, INTEGRALE, ID_SERIE, ID_ALBUM);
CREATE INDEX ALBUMS_IDX7 ON ALBUMS (ANNEEPARUTION, HORSSERIE, INTEGRALE, ACHAT, ID_ALBUM);
CREATE INDEX ALBUMS_IDX8 ON ALBUMS (ID_SERIE, ID_ALBUM);
CREATE INDEX COUVERTURES_IDX1 ON COUVERTURES (ORDRE, ID_COUVERTURE);
CREATE INDEX COUVERTURES_IDX2 ON COUVERTURES (ID_EDITION, ID_COUVERTURE);
CREATE INDEX COUVERTURES_IDX3 ON COUVERTURES (CATEGORIEIMAGE, ID_COUVERTURE);
CREATE INDEX EDITEURS_IDX1 ON EDITEURS (NOMEDITEUR);
CREATE INDEX EDITEURS_IDX2 ON EDITEURS (INITIALENOMEDITEUR, ID_EDITEUR);
CREATE INDEX EDITIONS_IDX1 ON EDITIONS (ID_COLLECTION, ID_EDITION);
CREATE INDEX EDITIONS_IDX2 ON EDITIONS (ETAT, ID_EDITION);
CREATE INDEX EDITIONS_IDX3 ON EDITIONS (RELIURE, ID_EDITION);
CREATE INDEX EDITIONS_IDX4 ON EDITIONS (TYPEEDITION, ID_EDITION);
CREATE INDEX EDITIONS_IDX5 ON EDITIONS (ORIENTATION, ID_EDITION);
CREATE INDEX EDITIONS_IDX6 ON EDITIONS (FORMATEDITION, ID_EDITION);
CREATE INDEX EMPRUNTEURS_IDX1 ON EMPRUNTEURS (INITIALENOMEMPRUNTEUR, ID_EMPRUNTEUR);
CREATE INDEX EMPRUNTEURS_IDX2 ON EMPRUNTEURS (NOMEMPRUNTEUR);
CREATE INDEX GENRES_IDX2 ON GENRES (GENRE);
CREATE INDEX GENRES_IDX3 ON GENRES (INITIALEGENRE, ID_GENRE);
CREATE INDEX LISTES_IDX1 ON LISTES (REF, ID_LISTE);
CREATE INDEX LISTES_IDX2 ON LISTES (CATEGORIE, ID_LISTE);
CREATE INDEX PARABD_IDX1 ON PARABD (CATEGORIEPARABD, ID_PARABD);
CREATE INDEX PARABD_IDX2 ON PARABD (ID_SERIE, ID_PARABD);
CREATE INDEX PARABD_IDX3 ON PARABD (INITIALETITREPARABD, ID_PARABD);
CREATE INDEX PARABD_IDX4 ON PARABD (TITREPARABD);
CREATE INDEX PERSONNES_IDX1 ON PERSONNES (NOMPERSONNE);
CREATE INDEX PERSONNES_IDX2 ON PERSONNES (INITIALENOMPERSONNE, ID_PERSONNE);
CREATE INDEX PHOTOS_IDX1 ON PHOTOS (ORDRE, ID_PHOTO);
CREATE INDEX SERIES_IDX1 ON SERIES (INITIALETITRESERIE, ID_SERIE);
CREATE INDEX SERIES_IDX2 ON SERIES (TERMINEE, ID_SERIE);
CREATE INDEX SERIES_IDX3 ON SERIES (ID_COLLECTION, ID_SERIE);
CREATE INDEX SERIES_IDX4 ON SERIES (ID_EDITEUR, ID_SERIE);
CREATE INDEX SERIES_IDX5 ON SERIES (TITRESERIE);
CREATE INDEX UNIVERS_IDX1 ON UNIVERS (ID_UNIVERS_PARENT, ID_UNIVERS);
CREATE INDEX UNIVERS_IDX2 ON UNIVERS (BRANCHE_UNIVERS);


/******************************************************************************/
/*                                  Triggers                                  */
/******************************************************************************/



/******************************************************************************/
/*                            Triggers for tables                             */
/******************************************************************************/



/* Trigger: ALBUMS_AIU0 */
CREATE TRIGGER ALBUMS_AIU0 FOR ALBUMS
    ACTIVE AFTER INSERT OR UPDATE POSITION 0
    as
declare variable id_univers type of column series_univers.id_univers;
begin
if (old.id_serie is distinct from new.id_serie) then
begin
if (old.id_serie is not null) then
update albums_univers set
    source_serie = 0
where
        id_album = new.id_album;

if (new.id_serie is not null) then
      for
select
    id_univers
from
    series_univers
where
        id_serie = new.id_serie
    into
          :id_univers
do
update or insert into albums_univers (
    id_album, id_univers, source_serie
) values (
    new.id_album, :id_univers, 1
    );
end
end;

/* Trigger: ALBUMS_DV */
CREATE TRIGGER ALBUMS_DV FOR ALBUMS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (new.titrealbum is null) then begin
    new.soundextitrealbum = null;
new.initialetitrealbum = null;
end else
  if (new.titrealbum is distinct from old.titrealbum) then begin
new.soundextitrealbum = udf_soundex(new.titrealbum, 1);
select initiale from get_initiale(new.titrealbum) into new.initialetitrealbum;
end
end;

/* Trigger: ALBUMS_LOGSUP_AD0 */
CREATE TRIGGER ALBUMS_LOGSUP_AD0 FOR ALBUMS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('ALBUMS', 'id_album', old.id_album);
end;

/* Trigger: ALBUMS_UNIQID_BIU0 */
CREATE TRIGGER ALBUMS_UNIQID_BIU0 FOR ALBUMS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_ALBUM is null) then new.ID_ALBUM = old.ID_ALBUM;
if (new.ID_ALBUM is null) then new.ID_ALBUM = udf_createguid();

if (new.dc_ALBUMS is null) then new.dc_ALBUMS = old.dc_ALBUMS;

if (new.dm_ALBUMS is not distinct from old.dm_ALBUMS) then
    new.dm_ALBUMS = cast('now' as timestamp);
if (inserting or new.dc_ALBUMS is null) then new.dc_ALBUMS = new.dm_ALBUMS;
end;

/* Trigger: ALBUMS_UNIVERS_AU0 */
CREATE TRIGGER ALBUMS_UNIVERS_AU0 FOR ALBUMS_UNIVERS
    ACTIVE AFTER UPDATE POSITION 0
                     as
begin
if (new.source_serie = 0 and new.source_album = 0) then
delete from albums_univers where id_album = new.id_album and id_univers = new.id_univers;
end;

/* Trigger: ALBUMS_UNIVERS_LOGSUP_AD0 */
CREATE TRIGGER ALBUMS_UNIVERS_LOGSUP_AD0 FOR ALBUMS_UNIVERS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('ALBUMS_UNIVERS', 'id_album_univers', old.id_album_univers);
end;

/* Trigger: ALBUMS_UNIVERS_UNIQID_BIU0 */
CREATE TRIGGER ALBUMS_UNIVERS_UNIQID_BIU0 FOR ALBUMS_UNIVERS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_ALBUM_UNIVERS is null) then new.ID_ALBUM_UNIVERS = old.ID_ALBUM_UNIVERS;
if (new.ID_ALBUM_UNIVERS is null) then new.ID_ALBUM_UNIVERS = udf_createguid();

if (new.dc_ALBUMS_UNIVERS is null) then new.dc_ALBUMS_UNIVERS = old.dc_ALBUMS_UNIVERS;

if (new.dm_ALBUMS_UNIVERS is not distinct from old.dm_ALBUMS_UNIVERS) then
    new.dm_ALBUMS_UNIVERS = cast('now' as timestamp);
if (inserting or new.dc_ALBUMS_UNIVERS is null) then new.dc_ALBUMS_UNIVERS = new.dm_ALBUMS_UNIVERS;
end;

/* Trigger: AUTEURS_LOGSUP_AD0 */
CREATE TRIGGER AUTEURS_LOGSUP_AD0 FOR AUTEURS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('AUTEURS', 'id_auteur', old.id_auteur);
end;

/* Trigger: AUTEURS_PARABD_LOGSUP_AD0 */
CREATE TRIGGER AUTEURS_PARABD_LOGSUP_AD0 FOR AUTEURS_PARABD
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('AUTEURS_PARABD', 'id_auteur_parabd', old.id_auteur_parabd);
end;

/* Trigger: AUTEURS_PARABD_UNIQID_BIU0 */
CREATE TRIGGER AUTEURS_PARABD_UNIQID_BIU0 FOR AUTEURS_PARABD
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_AUTEUR_PARABD is null) then new.ID_AUTEUR_PARABD = old.ID_AUTEUR_PARABD;
if (new.ID_AUTEUR_PARABD is null) then new.ID_AUTEUR_PARABD = udf_createguid();

if (new.dc_AUTEURS_PARABD is null) then new.dc_AUTEURS_PARABD = old.dc_AUTEURS_PARABD;

if (new.dm_AUTEURS_PARABD is not distinct from old.dm_AUTEURS_PARABD) then
    new.dm_AUTEURS_PARABD = cast('now' as timestamp);
if (inserting or new.dc_AUTEURS_PARABD is null) then new.dc_AUTEURS_PARABD = new.dm_AUTEURS_PARABD;
end;

/* Trigger: AUTEURS_SERIES_LOGSUP_AD0 */
CREATE TRIGGER AUTEURS_SERIES_LOGSUP_AD0 FOR AUTEURS_SERIES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('AUTEURS_SERIES', 'id_auteur_series', old.id_auteur_series);
end;

/* Trigger: AUTEURS_SERIES_UNIQID_BIU0 */
CREATE TRIGGER AUTEURS_SERIES_UNIQID_BIU0 FOR AUTEURS_SERIES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_AUTEUR_SERIES is null) then new.ID_AUTEUR_SERIES = old.ID_AUTEUR_SERIES;
if (new.ID_AUTEUR_SERIES is null) then new.ID_AUTEUR_SERIES = udf_createguid();

if (new.dc_AUTEURS_SERIES is null) then new.dc_AUTEURS_SERIES = old.dc_AUTEURS_SERIES;

if (new.dm_AUTEURS_SERIES is not distinct from old.dm_AUTEURS_SERIES) then
    new.dm_AUTEURS_SERIES = cast('now' as timestamp);
if (inserting or new.dc_AUTEURS_SERIES is null) then new.dc_AUTEURS_SERIES = new.dm_AUTEURS_SERIES;
end;

/* Trigger: AUTEURS_UNIQID_BIU0 */
CREATE TRIGGER AUTEURS_UNIQID_BIU0 FOR AUTEURS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_AUTEUR is null) then new.ID_AUTEUR = old.ID_AUTEUR;
if (new.ID_AUTEUR is null) then new.ID_AUTEUR = udf_createguid();

if (new.dc_AUTEURS is null) then new.dc_AUTEURS = old.dc_AUTEURS;

if (new.dm_AUTEURS is not distinct from old.dm_AUTEURS) then
    new.dm_AUTEURS = cast('now' as timestamp);
if (inserting or new.dc_AUTEURS is null) then new.dc_AUTEURS = new.dm_AUTEURS;
end;

/* Trigger: COLLECTIONS_DV */
CREATE TRIGGER COLLECTIONS_DV FOR COLLECTIONS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (inserting or new.nomcollection <> old.nomcollection) then begin
select initiale from get_initiale(new.nomcollection) into new.initialenomcollection;
end
end;

/* Trigger: COLLECTIONS_EDITIONS_REF */
CREATE TRIGGER COLLECTIONS_EDITIONS_REF FOR COLLECTIONS
    ACTIVE AFTER UPDATE OR DELETE POSITION 0
                     as
begin
if (deleting) then update editions set id_collection = null where id_collection = old.id_collection;
if (updating) then update editions set id_collection = new.id_collection, id_editeur = new.id_editeur where id_collection = old.id_collection;
end;;

/* Trigger: COLLECTIONS_LOGSUP_AD0 */
CREATE TRIGGER COLLECTIONS_LOGSUP_AD0 FOR COLLECTIONS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('COLLECTIONS', 'id_collection', old.id_collection);
end;

/* Trigger: COLLECTIONS_SERIE_REF */
CREATE TRIGGER COLLECTIONS_SERIE_REF FOR COLLECTIONS
    ACTIVE AFTER UPDATE OR DELETE POSITION 0
                     as
begin
if (deleting) then update series set id_collection = null where id_collection = old.id_collection;
if (updating) then update series set id_collection = new.id_collection, id_editeur = new.id_editeur where id_collection = old.id_collection;
end;;

/* Trigger: COLLECTIONS_UNIQID_BIU0 */
CREATE TRIGGER COLLECTIONS_UNIQID_BIU0 FOR COLLECTIONS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_COLLECTION is null) then new.ID_COLLECTION = old.ID_COLLECTION;
if (new.ID_COLLECTION is null) then new.ID_COLLECTION = udf_createguid();

if (new.dc_COLLECTIONS is null) then new.dc_COLLECTIONS = old.dc_COLLECTIONS;

if (new.dm_COLLECTIONS is not distinct from old.dm_COLLECTIONS) then
    new.dm_COLLECTIONS = cast('now' as timestamp);
if (inserting or new.dc_COLLECTIONS is null) then new.dc_COLLECTIONS = new.dm_COLLECTIONS;
end;

/* Trigger: CONVERSIONS_LOGSUP_AD0 */
CREATE TRIGGER CONVERSIONS_LOGSUP_AD0 FOR CONVERSIONS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('CONVERSIONS', 'id_conversion', old.id_conversion);
end;

/* Trigger: CONVERSIONS_UNIQID_BIU0 */
CREATE TRIGGER CONVERSIONS_UNIQID_BIU0 FOR CONVERSIONS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_CONVERSION is null) then new.ID_CONVERSION = old.ID_CONVERSION;
if (new.ID_CONVERSION is null) then new.ID_CONVERSION = udf_createguid();

if (new.dc_CONVERSIONS is null) then new.dc_CONVERSIONS = old.dc_CONVERSIONS;

if (new.dm_CONVERSIONS is not distinct from old.dm_CONVERSIONS) then
    new.dm_CONVERSIONS = cast('now' as timestamp);
if (inserting or new.dc_CONVERSIONS is null) then new.dc_CONVERSIONS = new.dm_CONVERSIONS;
end;

/* Trigger: COTES_LOGSUP_AD0 */
CREATE TRIGGER COTES_LOGSUP_AD0 FOR COTES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('COTES', 'id_cote', old.id_cote);
end;

/* Trigger: COTES_PARABD_LOGSUP_AD0 */
CREATE TRIGGER COTES_PARABD_LOGSUP_AD0 FOR COTES_PARABD
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('COTES_PARABD', 'id_cote_parabd', old.id_cote_parabd);
end;

/* Trigger: COTES_PARABD_UNIQID_BIU0 */
CREATE TRIGGER COTES_PARABD_UNIQID_BIU0 FOR COTES_PARABD
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_COTE_PARABD is null) then new.ID_COTE_PARABD = old.ID_COTE_PARABD;
if (new.ID_COTE_PARABD is null) then new.ID_COTE_PARABD = udf_createguid();

if (new.dc_COTES_PARABD is null) then new.dc_COTES_PARABD = old.dc_COTES_PARABD;

if (new.dm_COTES_PARABD is not distinct from old.dm_COTES_PARABD) then
    new.dm_COTES_PARABD = cast('now' as timestamp);
if (inserting or new.dc_COTES_PARABD is null) then new.dc_COTES_PARABD = new.dm_COTES_PARABD;
end;

/* Trigger: COTES_UNIQID_BIU0 */
CREATE TRIGGER COTES_UNIQID_BIU0 FOR COTES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_COTE is null) then new.ID_COTE = old.ID_COTE;
if (new.ID_COTE is null) then new.ID_COTE = udf_createguid();

if (new.dc_COTES is null) then new.dc_COTES = old.dc_COTES;

if (new.dm_COTES is not distinct from old.dm_COTES) then
    new.dm_COTES = cast('now' as timestamp);
if (inserting or new.dc_COTES is null) then new.dc_COTES = new.dm_COTES;
end;

/* Trigger: COUVERTURES_LOGSUP_AD0 */
CREATE TRIGGER COUVERTURES_LOGSUP_AD0 FOR COUVERTURES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('COUVERTURES', 'id_couverture', old.id_couverture);
end;

/* Trigger: COUVERTURES_UNIQID_BIU0 */
CREATE TRIGGER COUVERTURES_UNIQID_BIU0 FOR COUVERTURES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_COUVERTURE is null) then new.ID_COUVERTURE = old.ID_COUVERTURE;
if (new.ID_COUVERTURE is null) then new.ID_COUVERTURE = udf_createguid();

if (new.dc_COUVERTURES is null) then new.dc_COUVERTURES = old.dc_COUVERTURES;

if (new.dm_COUVERTURES is not distinct from old.dm_COUVERTURES) then
    new.dm_COUVERTURES = cast('now' as timestamp);
if (inserting or new.dc_COUVERTURES is null) then new.dc_COUVERTURES = new.dm_COUVERTURES;
end;

/* Trigger: CRITERES_LOGSUP_AD0 */
CREATE TRIGGER CRITERES_LOGSUP_AD0 FOR CRITERES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('CRITERES', 'id_critere', old.id_critere);
end;

/* Trigger: EDITEURS_DV */
CREATE TRIGGER EDITEURS_DV FOR EDITEURS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (inserting or new.nomediteur <> old.nomediteur) then begin
select initiale from get_initiale(new.nomediteur) into new.initialenomediteur;
end
end;

/* Trigger: EDITEURS_LOGSUP_AD0 */
CREATE TRIGGER EDITEURS_LOGSUP_AD0 FOR EDITEURS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('EDITEURS', 'id_editeur', old.id_editeur);
end;

/* Trigger: EDITEURS_SERIE_REF */
CREATE TRIGGER EDITEURS_SERIE_REF FOR EDITEURS
    ACTIVE AFTER UPDATE OR DELETE POSITION 0
                     as
begin
if (deleting) then update series set id_editeur = null where id_editeur = old.id_editeur;
if (updating) then update series set id_editeur = new.id_editeur where id_editeur = old.id_editeur;
end;;

/* Trigger: EDITEURS_UNIQID_BIU0 */
CREATE TRIGGER EDITEURS_UNIQID_BIU0 FOR EDITEURS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_EDITEUR is null) then new.ID_EDITEUR = old.ID_EDITEUR;
if (new.ID_EDITEUR is null) then new.ID_EDITEUR = udf_createguid();

if (new.dc_EDITEURS is null) then new.dc_EDITEURS = old.dc_EDITEURS;

if (new.dm_EDITEURS is not distinct from old.dm_EDITEURS) then
    new.dm_EDITEURS = cast('now' as timestamp);
if (inserting or new.dc_EDITEURS is null) then new.dc_EDITEURS = new.dm_EDITEURS;
end;

/* Trigger: EDITIONS_AD0 */
CREATE TRIGGER EDITIONS_AD0 FOR EDITIONS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
delete from couvertures where id_album is null and id_edition = old.id_edition;
update couvertures set id_edition = null where id_edition = old.id_edition;

update albums set nbeditions = nbeditions - 1 where id_album = old.id_album;
end;

/* Trigger: EDITIONS_AI0 */
CREATE TRIGGER EDITIONS_AI0 FOR EDITIONS
    ACTIVE AFTER INSERT POSITION 0
                     as
begin
update albums set nbeditions = nbeditions + 1 where id_album = new.id_album;
end;

/* Trigger: EDITIONS_AU0 */
CREATE TRIGGER EDITIONS_AU0 FOR EDITIONS
    ACTIVE AFTER UPDATE POSITION 0
                     as
begin
if (new.id_edition <> old.id_edition) then begin
update couvertures set id_edition = new.id_edition where id_edition = old.id_edition;
end

    if (new.id_album <> old.id_album) then begin
update albums set nbeditions = nbeditions - 1 where id_album = old.id_album;
update albums set nbeditions = nbeditions + 1 where id_album = new.id_album;
end
end;

/* Trigger: EDITIONS_BU0 */
CREATE TRIGGER EDITIONS_BU0 FOR EDITIONS
    ACTIVE BEFORE UPDATE POSITION 0
                      as
begin
if (updating and new.prete <> old.prete) then new.stock = 1 - new.prete;
end;

/* Trigger: EDITIONS_COTE_BIU1 */
CREATE TRIGGER EDITIONS_COTE_BIU1 FOR EDITIONS
    ACTIVE AFTER INSERT OR UPDATE POSITION 1
    as
declare variable existprix integer;
begin
if (new.anneecote is not null and new.prixcote is not null) then begin
select count(prixcote) from cotes where id_edition = new.id_edition and anneecote = new.anneecote into :existprix;
if (existprix = 0) then
insert into cotes (id_edition, anneecote, prixcote) values (new.id_edition, new.anneecote, new.prixcote);
else
update cotes set prixcote = new.prixcote where id_edition = new.id_edition and anneecote = new.anneecote;
end
end;

/* Trigger: EDITIONS_LOGSUP_AD0 */
CREATE TRIGGER EDITIONS_LOGSUP_AD0 FOR EDITIONS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('EDITIONS', 'id_edition', old.id_edition);
end;

/* Trigger: EDITIONS_UNIQID_BIU0 */
CREATE TRIGGER EDITIONS_UNIQID_BIU0 FOR EDITIONS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_EDITION is null) then new.ID_EDITION = old.ID_EDITION;
if (new.ID_EDITION is null) then new.ID_EDITION = udf_createguid();

if (new.dc_EDITIONS is null) then new.dc_EDITIONS = old.dc_EDITIONS;

if (new.dm_EDITIONS is not distinct from old.dm_EDITIONS) then
    new.dm_EDITIONS = cast('now' as timestamp);
if (inserting or new.dc_EDITIONS is null) then new.dc_EDITIONS = new.dm_EDITIONS;
end;

/* Trigger: EMPRUNTEURS_DV */
CREATE TRIGGER EMPRUNTEURS_DV FOR EMPRUNTEURS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (inserting or new.nomemprunteur <> old.nomemprunteur) then begin
select initiale from get_initiale(new.nomemprunteur) into new.initialenomemprunteur;
end
end;

/* Trigger: EMPRUNTEURS_LOGSUP_AD0 */
CREATE TRIGGER EMPRUNTEURS_LOGSUP_AD0 FOR EMPRUNTEURS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('EMPRUNTEURS', 'id_emprunteur', old.id_emprunteur);
end;

/* Trigger: EMPRUNTEURS_UNIQID_BIU0 */
CREATE TRIGGER EMPRUNTEURS_UNIQID_BIU0 FOR EMPRUNTEURS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_EMPRUNTEUR is null) then new.ID_EMPRUNTEUR = old.ID_EMPRUNTEUR;
if (new.ID_EMPRUNTEUR is null) then new.ID_EMPRUNTEUR = udf_createguid();

if (new.dc_EMPRUNTEURS is null) then new.dc_EMPRUNTEURS = old.dc_EMPRUNTEURS;

if (new.dm_EMPRUNTEURS is not distinct from old.dm_EMPRUNTEURS) then
    new.dm_EMPRUNTEURS = cast('now' as timestamp);
if (inserting or new.dc_EMPRUNTEURS is null) then new.dc_EMPRUNTEURS = new.dm_EMPRUNTEURS;
end;

/* Trigger: GENRESERIES_LOGSUP_AD0 */
CREATE TRIGGER GENRESERIES_LOGSUP_AD0 FOR GENRESERIES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('GENRESERIES', 'id_genreseries', old.id_genreseries);
end;

/* Trigger: GENRESERIES_UNIQID_BIU0 */
CREATE TRIGGER GENRESERIES_UNIQID_BIU0 FOR GENRESERIES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_GENRESERIES is null) then new.ID_GENRESERIES = old.ID_GENRESERIES;
if (new.ID_GENRESERIES is null) then new.ID_GENRESERIES = udf_createguid();

if (new.dc_GENRESERIES is null) then new.dc_GENRESERIES = old.dc_GENRESERIES;

if (new.dm_GENRESERIES is not distinct from old.dm_GENRESERIES) then
    new.dm_GENRESERIES = cast('now' as timestamp);
if (inserting or new.dc_GENRESERIES is null) then new.dc_GENRESERIES = new.dm_GENRESERIES;
end;

/* Trigger: GENRES_AD0 */
CREATE TRIGGER GENRES_AD0 FOR GENRES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
delete from import_associations where id = old.id_genre and typedata = 5;
end;

/* Trigger: GENRES_DV */
CREATE TRIGGER GENRES_DV FOR GENRES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (inserting or new.genre <> old.genre) then
begin
select
    initiale
from
    get_initiale(new.genre)
    into
      new.initialegenre;
end
end;

/* Trigger: GENRES_LOGSUP_AD0 */
CREATE TRIGGER GENRES_LOGSUP_AD0 FOR GENRES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('GENRES', 'id_genre', old.id_genre);
end;

/* Trigger: GENRES_UNIQID_BIU0 */
CREATE TRIGGER GENRES_UNIQID_BIU0 FOR GENRES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_GENRE is null) then new.ID_GENRE = old.ID_GENRE;
if (new.ID_GENRE is null) then new.ID_GENRE = udf_createguid();

if (new.dc_GENRES is null) then new.dc_GENRES = old.dc_GENRES;

if (new.dm_GENRES is not distinct from old.dm_GENRES) then
    new.dm_GENRES = cast('now' as timestamp);
if (inserting or new.dc_GENRES is null) then new.dc_GENRES = new.dm_GENRES;
end;

/* Trigger: LISTES_AUD0 */
CREATE TRIGGER LISTES_AUD0 FOR LISTES
    ACTIVE AFTER UPDATE OR DELETE POSITION 0
                     as
declare variable newvalue type of column listes.ref;
begin
if (deleting) then newvalue = null;
else newvalue = new.ref;

if (newvalue is distinct from old.ref) then
begin
if (old.categorie = 1) then begin
update editions set etat = :newvalue where etat = old.ref;
update series set etat = :newvalue where etat = old.ref;
end
    if (old.categorie = 2) then begin
update editions set reliure = :newvalue where reliure = old.ref;
update series set reliure = :newvalue where reliure = old.ref;
end
    if (old.categorie = 3) then begin
update editions set typeedition = :newvalue where typeedition = old.ref;
update series set typeedition = :newvalue where typeedition = old.ref;
end
    if (old.categorie = 4) then begin
update editions set orientation = :newvalue where orientation = old.ref;
update series set orientation = :newvalue where orientation = old.ref;
end
    if (old.categorie = 5) then begin
update editions set formatedition = :newvalue where formatedition = old.ref;
update series set formatedition = :newvalue where formatedition = old.ref;
end
    if (old.categorie = 6) then update couvertures set categorieimage = :newvalue where categorieimage = old.ref;
if (old.categorie = 7) then update parabd set categorieparabd = :newvalue where categorieparabd = old.ref;
if (old.categorie = 8) then begin
update editions set senslecture = :newvalue where senslecture = old.ref;
update series set senslecture = :newvalue where senslecture = old.ref;
end
    if (old.categorie = 9) then
begin
update albums set notation = :newvalue where notation = old.ref;
update series set notation = :newvalue where notation = old.ref;
end
    if (old.categorie = 10) then update photos set categorieimage = :newvalue where categorieimage = old.ref;
end
end
;;

/* Trigger: LISTES_LOGSUP_AD0 */
CREATE TRIGGER LISTES_LOGSUP_AD0 FOR LISTES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('LISTES', 'id_liste', old.id_liste);
end;

/* Trigger: LISTES_UNIQID_BIU0 */
CREATE TRIGGER LISTES_UNIQID_BIU0 FOR LISTES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_LISTE is null) then new.ID_LISTE = old.ID_LISTE;
if (new.ID_LISTE is null) then new.ID_LISTE = udf_createguid();

if (new.dc_LISTES is null) then new.dc_LISTES = old.dc_LISTES;

if (new.dm_LISTES is not distinct from old.dm_LISTES) then
    new.dm_LISTES = cast('now' as timestamp);
if (inserting or new.dc_LISTES is null) then new.dc_LISTES = new.dm_LISTES;
end;

/* Trigger: OPTIONS_LOGSUP_AD0 */
CREATE TRIGGER OPTIONS_LOGSUP_AD0 FOR OPTIONS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('OPTIONS', 'id_option', old.id_option);
end;

/* Trigger: OPTIONS_SCRIPTS_UNIQID_BIU0 */
CREATE TRIGGER OPTIONS_SCRIPTS_UNIQID_BIU0 FOR OPTIONS_SCRIPTS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_OPTION is null) then new.ID_OPTION = old.ID_OPTION;
if (new.ID_OPTION is null) then new.ID_OPTION = udf_createguid();

if (new.dc_OPTIONS_SCRIPTS is null) then new.dc_OPTIONS_SCRIPTS = old.dc_OPTIONS_SCRIPTS;

if (new.dm_OPTIONS_SCRIPTS is not distinct from old.dm_OPTIONS_SCRIPTS) then
    new.dm_OPTIONS_SCRIPTS = cast('now' as timestamp);
if (inserting or new.dc_OPTIONS_SCRIPTS is null) then new.dc_OPTIONS_SCRIPTS = new.dm_OPTIONS_SCRIPTS;
end;

/* Trigger: OPTIONS_UNIQID_BIU0 */
CREATE TRIGGER OPTIONS_UNIQID_BIU0 FOR OPTIONS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_OPTION is null) then new.ID_OPTION = old.ID_OPTION;
if (new.ID_OPTION is null) then new.ID_OPTION = udf_createguid();

if (new.dc_OPTIONS is null) then new.dc_OPTIONS = old.dc_OPTIONS;

if (new.dm_OPTIONS is not distinct from old.dm_OPTIONS) then
    new.dm_OPTIONS = cast('now' as timestamp);
if (inserting or new.dc_OPTIONS is null) then new.dc_OPTIONS = new.dm_OPTIONS;
end;

/* Trigger: PARABD_AIU0 */
CREATE TRIGGER PARABD_AIU0 FOR PARABD
    ACTIVE AFTER INSERT OR UPDATE POSITION 0
    as
declare variable id_univers type of column series_univers.id_univers;
begin
if (old.id_serie is distinct from new.id_serie) then
begin
if (old.id_serie is not null) then
update parabd_univers set
    source_serie = 0
where
        id_parabd = new.id_parabd;

if (new.id_serie is not null) then
      for
select
    id_univers
from
    series_univers
where
        id_serie = new.id_serie
    into
          :id_univers
do
update or insert into parabd_univers (
    id_parabd, id_univers, source_serie
) values (
    new.id_parabd, :id_univers, 1
    );
end
end;

/* Trigger: PARABD_COTE_BIU1 */
CREATE TRIGGER PARABD_COTE_BIU1 FOR PARABD
    ACTIVE AFTER INSERT OR UPDATE POSITION 1
    as
declare variable existprix integer;
begin
if (new.anneecote is not null and new.prixcote is not null) then begin
select count(prixcote) from cotes_parabd where id_parabd = new.id_parabd and anneecote = new.anneecote into :existprix;
if (existprix = 0) then
insert into cotes_parabd (id_parabd, anneecote, prixcote) values (new.id_parabd, new.anneecote, new.prixcote);
else
update cotes_parabd set prixcote = new.prixcote where id_parabd = new.id_parabd and anneecote = new.anneecote;
end
end;

/* Trigger: PARABD_DV */
CREATE TRIGGER PARABD_DV FOR PARABD
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (new.titreparabd is null) then
begin
new.soundextitreparabd = null;
new.initialetitreparabd = null;
end else
  if (new.titreparabd is distinct from old.titreparabd) then
begin
new.soundextitreparabd = udf_soundex(new.titreparabd, 1);
select initiale from get_initiale(new.titreparabd) into new.initialetitreparabd;
end
end;

/* Trigger: PARABD_LOGSUP_AD0 */
CREATE TRIGGER PARABD_LOGSUP_AD0 FOR PARABD
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('PARABD', 'id_parabd', old.id_parabd);
end;

/* Trigger: PARABD_UNIQID_BIU0 */
CREATE TRIGGER PARABD_UNIQID_BIU0 FOR PARABD
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_PARABD is null) then new.ID_PARABD = old.ID_PARABD;
if (new.ID_PARABD is null) then new.ID_PARABD = udf_createguid();

if (new.dc_PARABD is null) then new.dc_PARABD = old.dc_PARABD;

if (new.dm_PARABD is not distinct from old.dm_PARABD) then
    new.dm_PARABD = cast('now' as timestamp);
if (inserting or new.dc_PARABD is null) then new.dc_PARABD = new.dm_PARABD;
end;

/* Trigger: PARABD_UNIVERS_AU0 */
CREATE TRIGGER PARABD_UNIVERS_AU0 FOR PARABD_UNIVERS
    ACTIVE AFTER UPDATE POSITION 0
                     as
begin
if (new.source_serie = 0 and new.source_parabd = 0) then
delete from parabd_univers where id_parabd = new.id_parabd and id_univers = new.id_univers;
end;

/* Trigger: PARABD_UNIVERS_LOGSUP_AD0 */
CREATE TRIGGER PARABD_UNIVERS_LOGSUP_AD0 FOR PARABD_UNIVERS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('PARABD_UNIVERS', 'id_parabd_univers', old.id_parabd_univers);
end;

/* Trigger: PARABD_UNIVERS_UNIQID_BIU0 */
CREATE TRIGGER PARABD_UNIVERS_UNIQID_BIU0 FOR PARABD_UNIVERS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_PARABD_UNIVERS is null) then new.ID_PARABD_UNIVERS = old.ID_PARABD_UNIVERS;
if (new.ID_PARABD_UNIVERS is null) then new.ID_PARABD_UNIVERS = udf_createguid();

if (new.dc_PARABD_UNIVERS is null) then new.dc_PARABD_UNIVERS = old.dc_PARABD_UNIVERS;

if (new.dm_PARABD_UNIVERS is not distinct from old.dm_PARABD_UNIVERS) then
    new.dm_PARABD_UNIVERS = cast('now' as timestamp);
if (inserting or new.dc_PARABD_UNIVERS is null) then new.dc_PARABD_UNIVERS = new.dm_PARABD_UNIVERS;
end;

/* Trigger: PERSONNES_DV */
CREATE TRIGGER PERSONNES_DV FOR PERSONNES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (inserting or new.nompersonne <> old.nompersonne) then begin
select initiale from get_initiale(new.nompersonne) into new.initialenompersonne;
end
end;

/* Trigger: PERSONNES_LOGSUP_AD0 */
CREATE TRIGGER PERSONNES_LOGSUP_AD0 FOR PERSONNES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('PERSONNES', 'id_personne', old.id_personne);
end;

/* Trigger: PERSONNES_UNIQID_BIU0 */
CREATE TRIGGER PERSONNES_UNIQID_BIU0 FOR PERSONNES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_PERSONNE is null) then new.ID_PERSONNE = old.ID_PERSONNE;
if (new.ID_PERSONNE is null) then new.ID_PERSONNE = udf_createguid();

if (new.dc_PERSONNES is null) then new.dc_PERSONNES = old.dc_PERSONNES;

if (new.dm_PERSONNES is not distinct from old.dm_PERSONNES) then
    new.dm_PERSONNES = cast('now' as timestamp);
if (inserting or new.dc_PERSONNES is null) then new.dc_PERSONNES = new.dm_PERSONNES;
end;

/* Trigger: PHOTOS_LOGSUP_AD0 */
CREATE TRIGGER PHOTOS_LOGSUP_AD0 FOR PHOTOS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('PHOTOS', 'id_photo', old.id_photo);
end;

/* Trigger: PHOTOS_UNIQID_BIU0 */
CREATE TRIGGER PHOTOS_UNIQID_BIU0 FOR PHOTOS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.id_photo is null) then new.id_photo = old.id_photo;
if (new.id_photo is null) then new.id_photo = udf_createguid();

if (new.dc_photos is null) then new.dc_photos = old.dc_photos;

if (new.dm_photos is not distinct from old.dm_photos) then
    new.dm_photos = cast('now' as timestamp);
if (inserting or new.dc_photos is null) then new.dc_photos = new.dm_photos;
end;

/* Trigger: SERIES_AD0 */
CREATE TRIGGER SERIES_AD0 FOR SERIES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
delete from albums where id_serie = old.id_serie;
delete from parabd where id_serie = old.id_serie;
end;

/* Trigger: SERIES_DV */
CREATE TRIGGER SERIES_DV FOR SERIES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (new.titreserie is distinct from old.titreserie) then begin
    new.soundextitreserie = udf_soundex(new.titreserie, 1);
select initiale from get_initiale(new.titreserie) into new.initialetitreserie;
end
end;

/* Trigger: SERIES_LOGSUP_AD0 */
CREATE TRIGGER SERIES_LOGSUP_AD0 FOR SERIES
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('SERIES', 'id_serie', old.id_serie);
end;

/* Trigger: SERIES_UNIQID_BIU0 */
CREATE TRIGGER SERIES_UNIQID_BIU0 FOR SERIES
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_SERIE is null) then new.ID_SERIE = old.ID_SERIE;
if (new.ID_SERIE is null) then new.ID_SERIE = udf_createguid();

if (new.dc_SERIES is null) then new.dc_SERIES = old.dc_SERIES;

if (new.dm_SERIES is not distinct from old.dm_SERIES) then
    new.dm_SERIES = cast('now' as timestamp);
if (inserting or new.dc_SERIES is null) then new.dc_SERIES = new.dm_SERIES;
end;

/* Trigger: SERIES_UNIVERS_AD0 */
CREATE TRIGGER SERIES_UNIVERS_AD0 FOR SERIES_UNIVERS
    ACTIVE AFTER DELETE POSITION 0
                     as
declare variable id_album type of column albums.id_album;
declare variable id_parabd type of column parabd.id_parabd;
begin
for
select
    id_album
from
    albums
where
        id_serie = old.id_serie
    into
      :id_album
do
update albums_univers set
    source_serie = 0
where
        id_album = :id_album
  and id_univers = old.id_univers;

for
select
    id_parabd
from
    parabd
where
        id_serie = old.id_serie
    into
      :id_parabd
do
update parabd_univers set
    source_serie = 0
where
        id_parabd = :id_parabd
  and id_univers = old.id_univers;
end;

/* Trigger: SERIES_UNIVERS_AI0 */
CREATE TRIGGER SERIES_UNIVERS_AI0 FOR SERIES_UNIVERS
    ACTIVE AFTER INSERT POSITION 0
                     as
declare variable id_album type of column albums.id_album;
declare variable id_parabd type of column parabd.id_parabd;
begin
for
select
    id_album
from
    albums
where
        id_serie = new.id_serie
    into
      :id_album
do
update or insert into albums_univers (
    id_album, id_univers, source_serie
) values (
    :id_album, new.id_univers, 1
    );

for
select
    id_parabd
from
    parabd
where
        id_serie = new.id_serie
    into
      :id_parabd
do
update or insert into parabd_univers (
    id_parabd, id_univers, source_serie
) values (
    :id_parabd, new.id_univers, 1
    );
end;

/* Trigger: SERIES_UNIVERS_LOGSUP_AD0 */
CREATE TRIGGER SERIES_UNIVERS_LOGSUP_AD0 FOR SERIES_UNIVERS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('SERIES_UNIVERS', 'id_serie_univers', old.id_serie_univers);
end;

/* Trigger: SERIES_UNIVERS_UNIQID_BIU0 */
CREATE TRIGGER SERIES_UNIVERS_UNIQID_BIU0 FOR SERIES_UNIVERS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_SERIE_UNIVERS is null) then new.ID_SERIE_UNIVERS = old.ID_SERIE_UNIVERS;
if (new.ID_SERIE_UNIVERS is null) then new.ID_SERIE_UNIVERS = udf_createguid();

if (new.dc_SERIES_UNIVERS is null) then new.dc_SERIES_UNIVERS = old.dc_SERIES_UNIVERS;

if (new.dm_SERIES_UNIVERS is not distinct from old.dm_SERIES_UNIVERS) then
    new.dm_SERIES_UNIVERS = cast('now' as timestamp);
if (inserting or new.dc_SERIES_UNIVERS is null) then new.dc_SERIES_UNIVERS = new.dm_SERIES_UNIVERS;
end;

/* Trigger: STATUT_LOGSUP_AD0 */
CREATE TRIGGER STATUT_LOGSUP_AD0 FOR STATUT
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('STATUT', 'id_statut', old.id_statut);
end;

/* Trigger: STATUT_UNIQID_BIU0 */
CREATE TRIGGER STATUT_UNIQID_BIU0 FOR STATUT
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_STATUT is null) then new.ID_STATUT = old.ID_STATUT;
if (new.ID_STATUT is null) then new.ID_STATUT = udf_createguid();

if (new.dc_STATUT is null) then new.dc_STATUT = old.dc_STATUT;

if (new.dm_STATUT is not distinct from old.dm_STATUT) then
    new.dm_STATUT = cast('now' as timestamp);
if (inserting or new.dc_STATUT is null) then new.dc_STATUT = new.dm_STATUT;
end;

/* Trigger: SUPPRESSIONS_UNIQID_BIU0 */
CREATE TRIGGER SUPPRESSIONS_UNIQID_BIU0 FOR SUPPRESSIONS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.id_suppression is null) then new.id_suppression = old.id_suppression;
if (new.id_suppression is null) then new.id_suppression = udf_createguid();

if (new.dc_suppressions is null) then new.dc_suppressions = old.dc_suppressions;

new.dm_suppressions = cast('now' as timestamp);
if (inserting or new.dc_suppressions is null) then new.dc_suppressions = new.dm_suppressions;
end;

/* Trigger: UNIVERS_AD0 */
CREATE TRIGGER UNIVERS_AD0 FOR UNIVERS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
update univers set
    id_univers_parent = null
where
        id_univers_parent = old.id_univers;
end;

/* Trigger: UNIVERS_AU0 */
CREATE TRIGGER UNIVERS_AU0 FOR UNIVERS
    ACTIVE AFTER UPDATE POSITION 0
                     as
begin
if (new.branche_univers is distinct from old.branche_univers) then
update univers set
    branche_univers = new.branche_univers || '|' || id_univers
where
        id_univers_parent = new.id_univers;
end;

/* Trigger: UNIVERS_DV */
CREATE TRIGGER UNIVERS_DV FOR UNIVERS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 1
    as
begin
if (new.nomunivers is distinct from old.nomunivers) then begin
select initiale from get_initiale(new.nomunivers) into new.initialenomunivers;
end

    if (new.id_univers_parent is null) then
begin
new.id_univers_racine = new.id_univers;
new.branche_univers = '|' || new.id_univers || '|';
end
    else
    if (new.id_univers_parent is distinct from old.id_univers_parent) then
select
    id_univers_racine, '|' || new.id_univers || branche_univers
from
    univers
where
        id_univers = new.id_univers_parent
    into
        new.id_univers_racine, new.branche_univers;
end;

/* Trigger: UNIVERS_LOGSUP_AD0 */
CREATE TRIGGER UNIVERS_LOGSUP_AD0 FOR UNIVERS
    ACTIVE AFTER DELETE POSITION 0
                     as
begin
insert into suppressions(tablename, fieldname, id) values ('UNIVERS', 'id_univers', old.id_univers);
end;

/* Trigger: UNIVERS_UNIQID_BIU0 */
CREATE TRIGGER UNIVERS_UNIQID_BIU0 FOR UNIVERS
    ACTIVE BEFORE INSERT OR UPDATE POSITION 0
    as
begin
if (new.ID_UNIVERS is null) then new.ID_UNIVERS = old.ID_UNIVERS;
if (new.ID_UNIVERS is null) then new.ID_UNIVERS = udf_createguid();

if (new.dc_UNIVERS is null) then new.dc_UNIVERS = old.dc_UNIVERS;

if (new.dm_UNIVERS is not distinct from old.dm_UNIVERS) then
    new.dm_UNIVERS = cast('now' as timestamp);
if (inserting or new.dc_UNIVERS is null) then new.dc_UNIVERS = new.dm_UNIVERS;
end;

/******************************************************************************/
/*                             Stored procedures                              */
/******************************************************************************/

ALTER PROCEDURE ACHATALBUMS_BY_EDITEUR (
    ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(133);
begin
if (:id_editeur = cast('' as char(38))) then
    swhere = 's.id_editeur is null ';
else
    swhere = 's.id_editeur = ''' || :id_editeur || ''' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';
for execute statement
    'select
      a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie,
      a.integrale, a.moisparution, a.anneeparution, a.notation, a.id_serie,
      s.titreserie, a.achat, a.complet
    from
      albums a
      left join series s on
        a.id_serie = s.id_serie
    where
      ' || :swhere || '
    order by
      coalesce(a.titrealbum, s.titreserie), s.titreserie,
      a.horsserie nulls first, a.integrale nulls first, a.tome nulls first,
      a.tomedebut nulls first, a.tomefin nulls first,
      a.anneeparution nulls first, a.moisparution nulls first'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_ANNEE (
    ANNEE TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(200);
begin
if (:annee = -1) then swhere = 'anneeparution is null ';
else swhere = 'anneeparution = ' || :annee || ' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';
for execute statement
    'select
      id_album, titrealbum, tome, tomedebut, tomefin, horsserie,
      integrale, moisparution, anneeparution, notation, id_serie,
      titreserie, achat, complet
    from
      vw_liste_albums
    where
      ' || :swhere || '
    order by
      coalesce(titrealbum, titreserie), titreserie, horsserie nulls first,
      integrale nulls first, tome nulls first, tomedebut nulls first,
      tomefin nulls first, anneeparution nulls first, moisparution nulls first'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_AUTEUR (
    ID_AUTEUR TYPE OF COLUMN PERSONNES.ID_PERSONNE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                METIER TYPE OF COLUMN AUTEURS.METIER,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(200);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre || ' ';
for execute statement
    'select
      a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie,
      a.integrale, a.moisparution, a.anneeparution, a.notation, a.id_serie,
      a.titreserie, au.metier, a.achat, a.complet
    from
      vw_liste_albums a
      inner join auteurs au on
        a.id_album = au.id_album
    where
      au.id_personne = ''' || :id_auteur || ''' ' || swhere || '
    order by
      titreserie, horsserie nulls first, integrale nulls first,
      tome nulls first, anneeparution nulls first, moisparution nulls first,
      coalesce(titrealbum, titreserie), metier'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :metier, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_COLLECTION (
    ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(200);
begin
if (:id_collection = cast('' as char(38))) then
    swhere = 'id_collection is null ';
else
    swhere = 'id_collection = ''' || :id_collection || ''' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';
for execute statement
    'select
      id_album, titrealbum, tome, tomedebut, tomefin, horsserie,
      integrale, moisparution, anneeparution, notation, id_serie,
      titreserie, achat, complet
    from
      VW_LISTE_COLLECTIONS_ALBUMS
    where
      ' || :swhere || '
    order by
      coalesce(titrealbum, titreserie), titreserie,
      horsserie nulls first, integrale nulls first, tome nulls first,
      tomedebut nulls first, tomefin nulls first,
      anneeparution nulls first, moisparution nulls first'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_EDITEUR (
    ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(133);
begin
if (:id_editeur = cast('' as char(38))) then
    swhere = 'id_editeur is null ';
else
    swhere = 'id_editeur = ''' || :id_editeur || ''' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';
for execute statement
    'select
      id_album, titrealbum, tome, tomedebut, tomefin, horsserie,
      integrale, moisparution, anneeparution, notation, id_serie,
      titreserie, achat, complet
    from
      vw_liste_editeurs_albums
    where
      ' || swhere || '
    order by
      coalesce(titrealbum, titreserie), titreserie,
      horsserie nulls first, integrale nulls first, tome nulls first,
      tomedebut nulls first, tomefin nulls first,
      anneeparution nulls first, moisparution nulls first'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_GENRE (
    ID_GENRE TYPE OF COLUMN GENRES.ID_GENRE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(200);
begin
if (:id_genre = cast('' as char(38))) then
    swhere = 'g.id_genre is null ';
else
    swhere = 'g.id_genre = ''' || :id_genre || ''' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';
for execute statement
    'select
      a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie,
      a.integrale, a.moisparution, a.anneeparution, a.notation, a.id_serie,
      a.titreserie, a.achat, a.complet
    from
      vw_liste_albums a
      left join genreseries gs on
        gs.id_serie = a.id_serie
      left join genres g on
        gs.id_genre = g.id_genre
    where ' || :swhere || '
    order by
      coalesce(a.titrealbum, a.titreserie), a.titreserie,
      a.horsserie nulls first, a.integrale nulls first, a.tome nulls first,
      a.tomedebut nulls first, a.tomefin nulls first,
      a.anneeparution nulls first, a.moisparution nulls first'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_INITIALE (
    INITIALE T_INITIALE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = ' and ' || filtre || ' ';
for execute statement
    'select
      a.id_album, a.titrealbum, a.tome, a.tomedebut, a.tomefin, a.horsserie,
      a.integrale, a.moisparution, a.anneeparution, a.notation, a.id_serie,
      s.titreserie, a.achat, a.complet
    from
      albums a
      left join series s on
        s.id_serie = a.id_serie
    where
      coalesce(a.initialetitrealbum, s.initialetitreserie) = ''' ||: initiale || ''' ' || swhere || '
    order by
      coalesce(a.titrealbum, s.titreserie), s.titreserie,
      a.horsserie nulls first, a.integrale nulls first, a.tome nulls first,
      a.tomedebut nulls first, a.tomefin nulls first,
      a.anneeparution nulls first, a.moisparution nulls first'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_SERIE (
    IN_ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET)
            AS
declare variable swhere varchar(130);
declare variable nom_vue varchar(8) = '';
begin
if (:in_id_serie = cast('' as char(38))) then
    swhere = 'id_serie is null ';
else
    swhere = 'id_serie = ''' || :in_id_serie || ''' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';

if (filtre containing 'univers') then
    nom_vue = '_univers';

for execute statement
    'select distinct
      id_album, titrealbum, tome, tomedebut, tomefin, horsserie,
      integrale, moisparution, anneeparution, notation, id_serie,
      titreserie, achat, complet
    from
      vw_liste_albums' || :nom_vue || '
    where
      ' || :swhere || '
    order by
      horsserie nulls first, integrale nulls first, tome nulls first,
      anneeparution nulls first, moisparution nulls first, titrealbum'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_BY_UNIVERS (
    IN_ID_UNIVERS TYPE OF COLUMN UNIVERS.ID_UNIVERS,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                TOMEDEBUT TYPE OF COLUMN ALBUMS.TOMEDEBUT,
                TOMEFIN TYPE OF COLUMN ALBUMS.TOMEFIN,
                HORSSERIE TYPE OF COLUMN ALBUMS.HORSSERIE,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                NOTATION TYPE OF COLUMN ALBUMS.NOTATION,
                ID_SERIE TYPE OF COLUMN ALBUMS.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET,
                ID_UNIVERS TYPE OF COLUMN UNIVERS.ID_UNIVERS,
                ID_UNIVERS_RACINE TYPE OF COLUMN UNIVERS.ID_UNIVERS_RACINE)
            AS
declare variable swhere varchar(130);
begin
if (:in_id_univers = cast('' as char(38))) then
    swhere = 'id_univers is null ';
else
    swhere = 'id_univers = ''' || :in_id_univers || ''' ';
if (filtre is not null and filtre <> '') then
    swhere = swhere || 'and ' || filtre || ' ';
for execute statement
    'select distinct
      id_album, titrealbum, tome, tomedebut, tomefin, horsserie,
      integrale, moisparution, anneeparution, notation, id_serie,
      titreserie, achat, complet, id_univers, id_univers_racine
    from
      vw_liste_albums_univers
    where
      ' || :swhere || '
    order by
      horsserie nulls first, integrale nulls first, tome nulls first,
      anneeparution nulls first, moisparution nulls first, titrealbum'
    into
      :id_album, :titrealbum, :tome, :tomedebut, :tomefin, :horsserie,
      :integrale, :moisparution, :anneeparution, :notation, :id_serie,
      :titreserie, :achat, :complet, :id_univers, :id_univers_racine
do
begin
suspend;
end
end;


ALTER PROCEDURE ALBUMS_MANQUANTS (
    WITHINTEGRALE TYPE OF T_YESNO,
    WITHACHAT TYPE OF T_YESNO,
    IN_IDSERIE TYPE OF COLUMN SERIES.ID_SERIE)
    RETURNS (
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                COUNTSERIE INTEGER,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
                NOMCOLLECTION TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT)
            AS
declare variable maxserie integer;
declare variable nb_albums integer;
declare variable currenttome integer;
declare variable ownedtome integer;
declare variable sumachat integer;
begin
if (withintegrale is null) then withintegrale = 1;
if (withachat is null) then withachat = 1;
for
select
    s.id_serie, s.nb_albums, max(a.tome), count(distinct a.tome),
    cast(sum(a.achat) as integer),
    e.id_editeur, e.nomediteur, c.id_collection, c.nomcollection
from
    liste_tomes(:withintegrale, :in_idserie) a
        /* pas de left join: on cherche les manquants pour complter les sries */
        inner join series s on
            a.id_serie = s.id_serie
        left join editeurs e on
            s.id_editeur = e.id_editeur
        left join collections c on
            s.id_collection = c.id_collection
where
        s.suivremanquants = 1
group by
    s.id_serie, s.titreserie, e.nomediteur, c.nomcollection,
    e.id_editeur, c.id_collection, s.nb_albums
order by
    s.titreserie, e.nomediteur, c.nomcollection
    into
      :id_serie, :nb_albums, :maxserie, :countserie,
      :sumachat,
      :id_editeur, :nomediteur, :id_collection, :nomcollection
do
begin
if (withachat = 0) then
      countserie = :countserie - :sumachat;
if (nb_albums is not null and nb_albums > 0 and nb_albums > maxserie) then
      maxserie = :nb_albums;
if (countserie <> maxserie) then
begin
currenttome = 0;
for
select distinct
    titreserie, tome, achat
from
    liste_tomes(:withintegrale, :id_serie) a
        inner join series s on
            a.id_serie = s.id_serie
order by
    tome
    into
          :titreserie, :ownedtome, :achat
do
begin
currenttome = currenttome + 1;
while ((currenttome <> ownedtome) and (currenttome < maxserie)) do
begin
tome = currenttome;
suspend;
currenttome = currenttome + 1;
end
    if ((withachat = 0) and (achat = 1)) then
begin
tome = ownedtome;
suspend;
end
end
    currenttome = currenttome + 1;
while (currenttome <= maxserie) do
begin
tome = currenttome;
suspend;
currenttome = currenttome + 1;
end
end
end

    /* on ne peut pas utiliser un "union": le order by de la premire requte
       est impratif */
    countserie = 0;
achat = null;
for
select
    s.id_serie, s.titreserie, s.nb_albums,
    e.id_editeur, e.nomediteur, c.id_collection, c.nomcollection
from
    series s
        left join editeurs e on
            s.id_editeur = e.id_editeur
        left join collections c on
            s.id_collection = c.id_collection
where
    not exists (select 1 from liste_tomes(:withintegrale, s.id_serie))
  and s.suivremanquants = 1 and s.nb_albums is not null
  and (:in_idserie is null or id_serie = :in_idserie)
    into
      :id_serie, :titreserie, :nb_albums,
      :id_editeur, :nomediteur, :id_collection, :nomcollection
do begin
currenttome = 1;
while (currenttome <= nb_albums) do
begin
tome = currenttome;
suspend;
currenttome = currenttome + 1;
end
end
end;


ALTER PROCEDURE ANNEES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                COUNTANNEE INTEGER)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

for execute statement
    'select
      cast(-1 as smallint), count(id_album)
    from
      vw_liste_albums
    where
      anneeparution is null ' || swhere || '
    group by
      anneeparution'
  into
    :anneeparution, :countannee
do
suspend;

for execute statement
    'select
      anneeparution, count(id_album)
    from
      vw_liste_albums
    where
      anneeparution is not null ' || swhere || '
    group by
      anneeparution'
  into
    :anneeparution, :countannee
do
suspend;
end;


ALTER PROCEDURE CALCUL_ANNEE_SORTIE (
    WITHACHAT T_YESNO,
    IN_IDSERIE TYPE OF COLUMN SERIES.ID_SERIE,
    SOMMEPONDEREE INTEGER,
    COMPTEALBUM INTEGER,
    MAXTOME TYPE OF COLUMN ALBUMS.TOME,
    MAXANNEE TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
    MAXMOIS TYPE OF COLUMN ALBUMS.MOISPARUTION)
    RETURNS (
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
                NOMCOLLECTION TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION)
            AS
declare variable maxtome2 integer;
begin
tome = maxtome + 1;

select
    cast(max(tomefin) + 1 as integer)
from
    albums
where
        horsserie = 0 and integrale = 1
  and id_serie = :in_idserie and (:withachat = 1 or achat = 0)
    into
    :maxtome2;

if (maxtome2 > tome) then tome = maxtome2;

select
    s.id_serie, s.titreserie,
    e.id_editeur, e.nomediteur,
    c.id_collection, c.nomcollection
from
    series s
        left join editeurs e on
            e.id_editeur = s.id_editeur
        left join collections c on
            c.id_collection = s.id_collection
where
        s.id_serie = :in_idserie
    into
    :id_serie, :titreserie,
    :id_editeur, :nomediteur,
    :id_collection, :nomcollection;

if (maxmois is null) then
begin
anneeparution = maxannee + ((tome - maxtome) * ((sommeponderee / 12) / comptealbum));
moisparution = null;
end
    else
begin
moisparution = maxmois + ((tome - maxtome) * (sommeponderee / comptealbum));
anneeparution = maxannee;
while (moisparution > 12) do
begin
moisparution = moisparution - 12;
anneeparution = anneeparution + 1;
end
end

    suspend;
end;


ALTER PROCEDURE COLLECTIONS_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                NOMCOLLECTION TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION,
                COUNTCOLLECTION INTEGER,
                ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

for execute statement
    'select
      cast(''-1'' as varchar(50)), count(id_album), null, null, null
    from
      vw_liste_collections_albums
    where
      id_collection is null ' || swhere || '
    group by
      nomcollection, id_collection'
    into
      :nomcollection, :countcollection, :id_collection, :nomediteur, :id_editeur
do
suspend;

for execute statement
    'select
      nomcollection, count(id_album), id_collection, nomediteur, id_editeur
    from
      vw_liste_collections_albums
    where
      id_collection is not null ' || swhere || '
    group by
      nomcollection, id_collection, nomediteur, id_editeur'
    into
      :nomcollection, :countcollection, :id_collection, :nomediteur, :id_editeur
do
suspend;
end;


ALTER PROCEDURE COLLECTIONS_BY_INITIALE (
    INITIALE T_INITIALE,
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
                NOMCOLLECTION TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre || ' ';
for execute statement
    'select
      id_collection, nomcollection, id_editeur, nomediteur
    from
      vw_liste_collections
    where
      initialenomcollection = ''' || :initiale || ''' ' || swhere || '
    order by
      nomcollection'
    into
      :id_collection, :nomcollection, :id_editeur, :nomediteur
do
suspend;
end;


ALTER PROCEDURE DELETEFILE (
    FICHIER VARCHAR(255) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                RESULT INTEGER)
            AS
begin
select udf_deletefile(:fichier) from rdb$database into :result;
suspend;
end;


ALTER PROCEDURE DIRECTORYCONTENT (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    SEARCHATTR INTEGER)
    RETURNS (
                SEARCHREC INTEGER,
                FILENAME VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
                FILESIZE INTEGER,
                FILEATTR INTEGER)
            AS
begin
select udf_findfilefirst(:chemin, :searchattr) from rdb$database into :searchrec;
if (searchrec < 0) then
    suspend;
else while (searchrec > 0) do begin
select
    cast(udf_extractfilename(:searchrec) as varchar(255)),
    udf_extractfilesize(:searchrec),
    udf_extractfileattr(:searchrec)
from rdb$database
    into
      :filename,
      :filesize,
      :fileattr;
select udf_findfilenext(:searchrec) from rdb$database into :searchrec;
suspend;
end
end;


ALTER PROCEDURE EDITEURS_ACHATALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                COUNTEDITEUR INTEGER,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

for execute statement
    'select
      cast(''-1'' as varchar(50)), count(id_album), null
    from
      vw_liste_editeurs_achatalbums
    where
      id_editeur is null ' || swhere || '
    group by
      nomediteur, id_editeur'
    into
      :nomediteur, :countediteur, :id_editeur
do
suspend;

for execute statement
    'select
      nomediteur, count(id_album), id_editeur
    from
      vw_liste_editeurs_achatalbums
    where
      id_editeur is not null ' || swhere || '
    group by
      nomediteur, id_editeur'
    into
      :nomediteur, :countediteur, :id_editeur
do
suspend;
end;


ALTER PROCEDURE EDITEURS_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                COUNTEDITEUR INTEGER,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

for execute statement
    'select
      cast(''-1'' as varchar(50)), count(id_album), null
    from
      vw_liste_editeurs_albums
    where
      id_editeur is null ' || swhere || '
    group by
      nomediteur, id_editeur'
    into
      :nomediteur, :countediteur, :id_editeur
do
suspend;

for execute statement
    'select
      nomediteur, count(id_album), id_editeur
    from
      vw_liste_editeurs_albums
    where
      id_editeur is not null ' || swhere || '
    group by
      nomediteur, id_editeur'
    into
      :nomediteur, :countediteur, :id_editeur
do
suspend;
end;


ALTER PROCEDURE EDITEURS_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR)
            AS
begin
for
select
    id_editeur, nomediteur
from
    editeurs
where
        initialenomediteur = :initiale
order by
    nomediteur
    into
      :id_editeur, :nomediteur
do
begin
suspend;
end
end;


ALTER PROCEDURE EMPRUNTEURS_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
                ID_EMPRUNTEUR TYPE OF COLUMN EMPRUNTEURS.ID_EMPRUNTEUR,
                NOMEMPRUNTEUR TYPE OF COLUMN EMPRUNTEURS.NOMEMPRUNTEUR)
            AS
begin
for
select
    id_emprunteur, nomemprunteur
from
    emprunteurs
where
        initialenomemprunteur = :initiale
order by
    nomemprunteur
    into
      :id_emprunteur, :nomemprunteur
do
begin
suspend;
end
end;


ALTER PROCEDURE GENRES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
                GENRE TYPE OF COLUMN GENRES.GENRE,
                COUNTGENRE INTEGER,
                ID_GENRE TYPE OF COLUMN GENRES.ID_GENRE)
            AS
declare variable swhere varchar(132);
begin
swhere = '';
if (coalesce(filtre, '') <> '') then
    swhere = 'and ' || filtre;

for execute statement 'select
      cast(''-1'' as varchar(30)), count(id_album), null
    from
      vw_liste_genres_albums
    where
      id_genre is null ' || swhere || '
    group by
      genre, id_genre'
        into :genre, :countgenre, :id_genre
do
suspend;

for execute statement 'select
      genre, count(id_album), id_genre
    from
      vw_liste_genres_albums
    where
      id_genre is not null ' || swhere || '
    group by
      genre, id_genre'
        into :genre, :countgenre, :id_genre
do
suspend;
end;


ALTER PROCEDURE GENRES_BY_INITIALE (
    INITIALE T_INITIALE_UTF8)
    RETURNS (
                ID_GENRE TYPE OF COLUMN GENRES.ID_GENRE,
                GENRE TYPE OF COLUMN GENRES.GENRE)
            AS
begin
for
select
    id_genre, genre
from
    genres
where
        initialegenre = :initiale
order by
    genre
    into
      :id_genre, :genre
do
suspend;
end;


ALTER PROCEDURE GET_INITIALE (
    CHAINE T_TITRE_UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
                INITIALE T_INITIALE_UTF8)
            AS
begin
initiale = upper(cast(substring(:chaine from 1 for 1) as char(1)));
if (not (initiale between 'A' and 'Z' or initiale between '0' and '9')) then
    initiale = '#';
suspend;
end;


ALTER PROCEDURE INITIALES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                INITIALETITREALBUM TYPE OF COLUMN ALBUMS.INITIALETITREALBUM,
                COUNTINITIALE INTEGER)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'where ' || filtre;
for execute statement
    'select
      coalesce(initialetitrealbum, initialetitreserie), count(id_album)
    from
      albums
      left join series on
        albums.id_serie = series.id_serie ' || swhere || '
    group by
      1'
    into
      :initialetitrealbum, :countinitiale
do
suspend;
end;


ALTER PROCEDURE INITIALES_COLLECTIONS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                INITIALENOMCOLLECTION TYPE OF COLUMN COLLECTIONS.INITIALENOMCOLLECTION,
                COUNTINITIALE INTEGER)
            AS
declare variable swhere varchar(133);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'where ' || filtre;
for execute statement
    'select
      initialenomcollection, count(id_collection)
    from
      collections ' || swhere || '
    group by
      initialenomcollection'
    into
      :initialenomcollection, :countinitiale
do
suspend;
end;


ALTER PROCEDURE INITIALES_UNIVERS (
    FILTRE VARCHAR(150) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
                INITIALENOMUNIVERS TYPE OF COLUMN UNIVERS.INITIALENOMUNIVERS,
                COUNTINITIALE INTEGER)
            AS
declare variable swhere varchar(156);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'where ' || filtre;
for execute statement
    'select
      initialenomunivers, count(id_univers)
    from
      univers ' || swhere || '
    group by
      1'
    into
      :initialenomunivers, :countinitiale
do
suspend;
end;


ALTER PROCEDURE LISTE_TOMES (
    WITHINTEGRALE T_YESNO,
    IN_IDSERIE TYPE OF COLUMN SERIES.ID_SERIE)
    RETURNS (
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                INTEGRALE TYPE OF COLUMN ALBUMS.INTEGRALE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT)
            AS
declare variable tomedebut type of column albums.tomedebut;
declare variable tomefin type of column albums.tomefin;
begin
for
select
    id_serie, tome, integrale, achat
from
    albums
where
    tome is not null and integrale = 0 and horsserie = 0
  and (:in_idserie is null or id_serie = :in_idserie)
order by
    id_serie, tome
    into
      :id_serie, :tome, :integrale, :achat
do
suspend;

if (withintegrale is null) then withintegrale = 1;
if (withintegrale = 1) then
    for
select
    id_serie, tomedebut, tomefin, integrale, achat
from
    albums
where
    tomedebut is not null and tomefin is not null
  and integrale = 1 and horsserie = 0
  and (:in_idserie is null or id_serie = :in_idserie)
order by
    id_serie, tomedebut, tomefin
    into
        :id_serie, :tomedebut, :tomefin, :integrale, :achat
do
begin
tome = tomedebut - 1;
while (tome <> tomefin) do
begin
tome = tome + 1;
suspend;
end
end
end;


ALTER PROCEDURE LOADBLOBFROMFILE (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    FICHIER VARCHAR(255) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                BLOBCONTENT BLOB SUB_TYPE 0 SEGMENT SIZE 80)
            AS
begin
select udf_loadblobfromfile(:chemin, :fichier) from rdb$database into :blobcontent;
suspend;
end;


ALTER PROCEDURE PARABD_BY_SERIE (
    IN_ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
    FILTRE VARCHAR(125) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
                ID_PARABD TYPE OF COLUMN PARABD.ID_PARABD,
                TITREPARABD TYPE OF COLUMN PARABD.TITREPARABD,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ACHAT TYPE OF COLUMN ALBUMS.ACHAT,
                COMPLET TYPE OF COLUMN ALBUMS.COMPLET,
                SCATEGORIE TYPE OF COLUMN LISTES.LIBELLE)
            AS
declare variable swhere varchar(130);
declare variable nom_vue varchar(8) = '';
begin
if (:in_id_serie = cast('' as t_guid)) then
    swhere = 'id_serie is null ';
else
    swhere = 'id_serie = ''' || :in_id_serie || ''' ';
if (coalesce(filtre, '') <> '') then
    swhere = swhere || 'and ' || filtre || ' ';

if (filtre containing 'univers') then
    nom_vue = '_univers';

for
execute statement 'select distinct
      id_parabd, titreparabd, id_parabd, titreserie, achat, complet, scategorie
    from
      vw_liste_parabd' || :nom_vue || '
    where
      ' || :swhere || '
    order by
      titreparabd'
    into
      :id_parabd, :titreparabd, :id_serie, :titreserie, :achat, :complet, :scategorie
do
suspend;
end;


ALTER PROCEDURE PERSONNES_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
                ID_PERSONNE TYPE OF COLUMN PERSONNES.ID_PERSONNE,
                NOMPERSONNE TYPE OF COLUMN PERSONNES.NOMPERSONNE)
            AS
begin
for
select
    id_personne, nompersonne
from
    personnes
where
        initialenompersonne = :initiale
order by
    nompersonne
    into
      :id_personne, :nompersonne
do
begin
suspend;
end
end;


ALTER PROCEDURE PREVISIONS_SORTIES (
    WITHACHAT T_YESNO,
    IN_ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE)
    RETURNS (
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                TERMINEE TYPE OF COLUMN SERIES.TERMINEE,
                TOME TYPE OF COLUMN ALBUMS.TOME,
                ANNEEPARUTION TYPE OF COLUMN ALBUMS.ANNEEPARUTION,
                MOISPARUTION TYPE OF COLUMN ALBUMS.MOISPARUTION,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
                NOMCOLLECTION TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION)
            AS
declare variable currentidserie type of column series.id_serie;
declare variable oldidserie type of column series.id_serie;
declare variable currenttome type of column albums.tome;
declare variable sommeponderee integer;
declare variable comptealbum integer;
declare variable currentannee type of column albums.anneeparution;
declare variable currentmois type of column albums.moisparution;
declare variable tomeprecedent type of column albums.tome;
declare variable anneeprecedente type of column albums.anneeparution;
declare variable moisprecedent type of column albums.moisparution;
declare variable diffmois integer;
begin
if (withachat is null) then withachat = 1;
oldidserie = null;
tomeprecedent = -1;
anneeprecedente = -1;
moisprecedent = null;
for
select
    tome, anneeparution, moisparution, s.id_serie
from
    albums a
        /* pas de left join: on calcul les prvisions de sorties des nouveauts des sries */
        inner join series s on
            s.id_serie = a.id_serie
where
        s.suivresorties = 1
  and a.horsserie = 0 and a.integrale = 0 and a.anneeparution is not null
  and (:in_id_serie is null or s.id_serie = :in_id_serie)
  and (:withachat = 1 or achat = 0)
order by
    s.id_serie, tome
    into
      :currenttome, :currentannee, :currentmois, :currentidserie
do
begin
if (oldidserie is null or currentidserie <> oldidserie) then
begin

if (oldidserie is not null and comptealbum > 0) then
begin
select
    sorties.id_serie, sorties.titreserie, sorties.tome, sorties.anneeparution, sorties.moisparution,
    sorties.id_editeur, sorties.nomediteur, sorties.id_collection, sorties.nomcollection,
    s.terminee
from
    calcul_annee_sortie(
        :withachat, :oldidserie, :sommeponderee, :comptealbum,
        :tomeprecedent, :anneeprecedente, :moisprecedent
        ) sorties
        inner join series s on
            s.id_serie = sorties.id_serie
    into
          :id_serie, :titreserie, :tome, :anneeparution, :moisparution,
          :id_editeur, :nomediteur, :id_collection, :nomcollection,
          :terminee;

suspend;
end

    oldidserie = currentidserie;
sommeponderee = 0;
comptealbum = 0;
tomeprecedent = -1;
anneeprecedente = -1;
moisprecedent = -1;
end
    if (tomeprecedent <> -1 and currenttome - tomeprecedent <> 0) then
begin
if (currentmois is null or moisprecedent is null) then
        diffmois = 0;
else
        diffmois = currentmois - moisprecedent;
      /* non pondr: sommeponderee = sommeponderee + (((currentannee - anneeprecedente) * 12 + (coalesce(currentmois, 1) - coalesce(moisprecedent, 1))) / (currenttome - tomeprecedent)); */
sommeponderee = sommeponderee + (((currentannee - anneeprecedente) * 12 + diffmois) / (currenttome - tomeprecedent)) * currenttome;
      /* non pondr: comptealbum = comptealbum + 1;*/
comptealbum = comptealbum + currenttome;
end
    tomeprecedent = currenttome;
anneeprecedente = currentannee;
moisprecedent = currentmois;
end

    if (oldidserie is not null and comptealbum > 0) then
begin
select
    sorties.id_serie, sorties.titreserie, sorties.tome, sorties.anneeparution, sorties.moisparution,
    sorties.id_editeur, sorties.nomediteur, sorties.id_collection, sorties.nomcollection,
    s.terminee
from
    calcul_annee_sortie(
        :withachat, :oldidserie, :sommeponderee, :comptealbum, :tomeprecedent,
        :anneeprecedente, :moisprecedent
        ) sorties
        inner join series s on
            s.id_serie = sorties.id_serie
    into
      :id_serie, :titreserie, :tome, :anneeparution, :moisparution,
      :id_editeur, :nomediteur, :id_collection, :nomcollection,
      :terminee;

suspend;
end
end;


ALTER PROCEDURE PROC_AJOUTMVT (
    ID_EDITION TYPE OF COLUMN EDITIONS.ID_EDITION,
    ID_EMPRUNTEUR TYPE OF COLUMN EMPRUNTEURS.ID_EMPRUNTEUR,
    DATEEMPRUNT TIMESTAMP,
    PRET TYPE OF COLUMN STATUT.PRETEMPRUNT)
    AS
begin
insert into statut (
    dateemprunt, id_emprunteur, id_edition, pretemprunt
) values (
             :dateemprunt, :id_emprunteur, :id_edition, :pret
         );

update editions set
    prete = :pret
where
        id_edition = :id_edition;
end;


ALTER PROCEDURE PROC_AUTEURS (
    ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
    SERIE TYPE OF COLUMN SERIES.ID_SERIE,
    PARABD TYPE OF COLUMN PARABD.ID_PARABD)
    RETURNS (
                ID_PERSONNE TYPE OF COLUMN PERSONNES.ID_PERSONNE,
                NOMPERSONNE TYPE OF COLUMN PERSONNES.NOMPERSONNE,
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                ID_PARABD TYPE OF COLUMN PARABD.ID_PARABD,
                METIER TYPE OF COLUMN AUTEURS.METIER)
            AS
begin
if (album is not null) then
    for
select
    p.id_personne, p.nompersonne,
    a.id_album, null, null, a.metier
from
    personnes p
        inner join auteurs a on
            a.id_personne = p.id_personne
where
        a.id_album = :album
order by
    a.metier, p.nompersonne
    into
        :id_personne, :nompersonne,
        :id_album, :id_serie, :id_parabd, :metier
do
suspend;

if (serie is not null) then
    for
select
    p.id_personne, p.nompersonne,
    null, a.id_serie, null, a.metier
from
    personnes p
        inner join auteurs_series a on
            a.id_personne = p.id_personne
where
        a.id_serie = :serie
order by
    a.metier, p.nompersonne
    into
        :id_personne, :nompersonne,
        :id_album, :id_serie, :id_parabd, :metier
do
suspend;

if (parabd is not null) then
    for
select
    p.id_personne, p.nompersonne,
    null, null, a.id_parabd, cast(null as smallint)
from
    personnes p
        inner join auteurs_parabd a on
            a.id_personne = p.id_personne
where
        a.id_parabd = :parabd
order by
    p.nompersonne
    into
        :id_personne, :nompersonne,
        :id_album, :id_serie, :id_parabd, :metier
do
suspend;
end;


ALTER PROCEDURE PROC_EMPRUNTS
    RETURNS (
                ID_EDITION TYPE OF COLUMN EDITIONS.ID_EDITION,
                ID_ALBUM TYPE OF COLUMN ALBUMS.ID_ALBUM,
                TITREALBUM TYPE OF COLUMN ALBUMS.TITREALBUM,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                PRETE TYPE OF COLUMN EDITIONS.PRETE,
                ID_EMPRUNTEUR TYPE OF COLUMN EMPRUNTEURS.ID_EMPRUNTEUR,
                NOMEMPRUNTEUR TYPE OF COLUMN EMPRUNTEURS.NOMEMPRUNTEUR,
                PRETEMPRUNT TYPE OF COLUMN STATUT.PRETEMPRUNT,
                DATEEMPRUNT TYPE OF COLUMN STATUT.DATEEMPRUNT)
            AS
begin
for
select
    ed.id_edition, a.id_album, a.titrealbum, a.id_serie, a.titreserie, ed.prete, e.id_emprunteur, e.nomemprunteur,
    s.pretemprunt, s.dateemprunt
from
    vw_liste_albums a
        inner join editions ed on a.id_album = ed.id_album
        inner join statut s on ed.id_edition = s.id_edition
        inner join emprunteurs e on e.id_emprunteur = s.id_emprunteur
order by
    s.dateemprunt desc
    into
      :id_edition, :id_album, :titrealbum, :id_serie, :titreserie, :prete, :id_emprunteur, :nomemprunteur, :pretemprunt,
      :dateemprunt
do
begin
suspend;
end
end;


ALTER PROCEDURE SAVEBLOBTOFILE (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    FICHIER VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    BLOBCONTENT BLOB SUB_TYPE 0 SEGMENT SIZE 80)
    RETURNS (
                RESULT INTEGER)
            AS
begin
select udf_saveblobtofile(:chemin, :fichier, :blobcontent) from rdb$database into :result;
suspend;
end;


ALTER PROCEDURE SEARCHFILENAME (
    CHEMIN VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    OLD_FILENAME VARCHAR(255) CHARACTER SET NONE COLLATE NONE,
    RESERVE INTEGER)
    RETURNS (
                NEW_FILENAME VARCHAR(255) CHARACTER SET NONE COLLATE NONE)
            AS
begin
select udf_searchfilename(:chemin, :old_filename, :reserve) from rdb$database into :new_filename;
suspend;
end;


ALTER PROCEDURE SERIES_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                COUNTSERIE INTEGER,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE)
            AS
declare variable swhere varchar(132);
declare variable nom_vue varchar(8) = '';
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

if (filtre containing 'univers') then
    nom_vue = '_univers';

for execute statement
    'select
      cast(''-1'' as varchar(150)), id_serie, count(distinct id_album)
    from
      vw_liste_albums' || :nom_vue || '
    where
      titreserie is null ' || swhere || '
    group by
      titreserie, id_serie'
    into
      :titreserie, :id_serie, :countserie
do
suspend;

for execute statement
    'select
      titreserie, id_serie, count(distinct id_album)
    from
      vw_liste_albums' || :nom_vue || '
    where
      titreserie is not null ' || swhere || '
    group by
      titreserie, id_serie'
    into
      :titreserie, :id_serie, :countserie
do
suspend;
end;


ALTER PROCEDURE SERIES_BY_INITIALE (
    INITIALE T_INITIALE)
    RETURNS (
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE,
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                ID_EDITEUR TYPE OF COLUMN EDITEURS.ID_EDITEUR,
                NOMEDITEUR TYPE OF COLUMN EDITEURS.NOMEDITEUR,
                ID_COLLECTION TYPE OF COLUMN COLLECTIONS.ID_COLLECTION,
                NOMCOLLECTION TYPE OF COLUMN COLLECTIONS.NOMCOLLECTION)
            AS
begin
for
select
    id_serie, s.titreserie,
    s.id_editeur, e.nomediteur, s.id_collection, c.nomcollection
from
    series s
        left join editeurs e on
            s.id_editeur = e.id_editeur
        left join collections c on
            s.id_collection = c.id_collection
where
        s.initialetitreserie = :initiale
order by
    s.titreserie, e.nomediteur, c.nomcollection
    into
        :id_serie, :titreserie,
        :id_editeur, :nomediteur, :id_collection, :nomcollection
do
begin
suspend;
end
end;


ALTER PROCEDURE SERIES_PARABD (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                TITRESERIE TYPE OF COLUMN SERIES.TITRESERIE,
                COUNTSERIE INTEGER,
                ID_SERIE TYPE OF COLUMN SERIES.ID_SERIE)
            AS
declare variable swhere varchar(132);
declare variable nom_vue varchar(8) = '';
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

if (filtre containing 'univers') then
    nom_vue = '_univers';

for execute statement
    'select
      cast(''-1'' as varchar(150)), id_serie, count(distinct id_parabd)
    from
      vw_liste_parabd' || :nom_vue || '
    where
      titreserie is null ' || swhere || '
    group by
      titreserie, id_serie'
    into
      :titreserie, :id_serie, :countserie
do
suspend;

for execute statement
    'select
      titreserie, id_serie, count(distinct id_parabd)
    from
      vw_liste_parabd' || :nom_vue || '
    where
      titreserie is not null ' || swhere || '
    group by
      titreserie, id_serie'
    into
      :titreserie, :id_serie, :countserie
do
suspend;
end;


ALTER PROCEDURE UNIVERS_ALBUMS (
    FILTRE VARCHAR(125) CHARACTER SET NONE COLLATE NONE)
    RETURNS (
                NOMUNIVERS TYPE OF COLUMN UNIVERS.NOMUNIVERS,
                COUNTUNIVERS INTEGER,
                ID_UNIVERS TYPE OF COLUMN UNIVERS.ID_UNIVERS)
            AS
declare variable swhere varchar(132);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = 'and ' || filtre;

for execute statement
    'select
      nomunivers, id_univers, count(distinct id_album)
    from
      vw_liste_albums_univers
    where
      id_univers is not null ' || swhere || '
    group by
      nomunivers, id_univers'
    into
      :nomunivers, :id_univers, :countunivers
do
suspend;
end;


ALTER PROCEDURE UNIVERS_BY_INITIALE (
    INITIALE T_INITIALE_UTF8,
    FILTRE VARCHAR(150) CHARACTER SET UTF8 COLLATE UTF8_FR_CI_AI)
    RETURNS (
                ID_UNIVERS TYPE OF COLUMN UNIVERS.ID_UNIVERS,
                NOMUNIVERS TYPE OF COLUMN UNIVERS.NOMUNIVERS)
            AS
declare variable swhere varchar(156);
begin
swhere = '';
if (filtre is not null and filtre <> '') then
    swhere = ' and ' || filtre || ' ';
for execute statement
    'select
      id_univers, nomunivers
    from
      univers
    where
      initialenomunivers = ''' ||: initiale || ''' ' || swhere || '
    order by
      nomunivers'
    into
      :id_univers, :nomunivers
do
suspend;
end;


