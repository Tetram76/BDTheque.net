schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface Error {
  message: String!
}

interface IAssociable {
  associations: [NonEmptyString!]
}

interface IMandatoryLabel {
  initiale: Char!
}

interface IOptionalLabel {
  initiale: Char
}

interface IUniqueId {
  id: ID!
}

interface IVersioning {
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Album implements IVersioning & IUniqueId & IAssociable & IOptionalLabel {
  anneeParution: Year
  associations: [NonEmptyString!]
  auteurs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AuteurSortInput!] where: AuteurFilterInput): AuteursConnection
  createdAt: DateTime!
  editions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): EditionsConnection
  genres("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GenreSortInput!] where: GenreFilterInput): GenresConnection
  horsSerie: Boolean
  id: ID!
  initiale: Char
  integrale: Boolean
  moisParution: Month
  notation: Option
  notes: NonEmptyString
  serie: Serie
  sujet: NonEmptyString
  titre: NonEmptyString
  tome: UnsignedShort
  tomeDebut: UnsignedShort
  tomeFin: UnsignedShort
  univers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): UniversConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type AlbumListConnection {
  "A list of edges."
  edges: [AlbumListEdge!]
  "A flattened list of the nodes."
  nodes: [Album!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type AlbumListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Album!
}

"A connection to a list of items."
type AlbumsConnection {
  "A list of edges."
  edges: [AlbumsEdge!]
  "A flattened list of the nodes."
  nodes: [Album!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type AlbumsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Album!
}

type AlreadyExistsError implements Error {
  message: String!
}

type Auteur implements IVersioning & IUniqueId {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  createdAt: DateTime!
  id: ID!
  metier: Metier!
  personne: Personne!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

type AuteurAlbum implements IVersioning {
  album: Album!
  auteur: Auteur!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AuteurSerie implements IVersioning {
  auteur: Auteur!
  createdAt: DateTime!
  serie: Serie!
  updatedAt: DateTime!
}

"A connection to a list of items."
type AuteursConnection {
  "A list of edges."
  edges: [AuteursEdge!]
  "A flattened list of the nodes."
  nodes: [Auteur!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type AuteursEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Auteur!
}

type Collection implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): AlbumsConnection
  associations: [NonEmptyString!]
  createdAt: DateTime!
  editeur: Editeur!
  id: ID!
  initiale: Char!
  nom: NonEmptyString!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type CollectionListConnection {
  "A list of edges."
  edges: [CollectionListEdge!]
  "A flattened list of the nodes."
  nodes: [Collection!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type CollectionListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Collection!
}

"A connection to a list of items."
type CollectionsConnection {
  "A list of edges."
  edges: [CollectionsEdge!]
  "A flattened list of the nodes."
  nodes: [Collection!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type CollectionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Collection!
}

type Cote implements IVersioning & IUniqueId {
  annee: Year
  createdAt: DateTime!
  editionAlbum: EditionAlbum!
  id: ID!
  prix: EuroCurrency
  updatedAt: DateTime!
}

"A connection to a list of items."
type CotesConnection {
  "A list of edges."
  edges: [CotesEdge!]
  "A flattened list of the nodes."
  nodes: [Cote!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type CotesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Cote!
}

type CreateAlbumPayload {
  album: Album
  errors: [CreateAlbumError!]
}

type CreateCollectionPayload {
  collection: Collection
  errors: [CreateCollectionError!]
}

type CreateEditeurPayload {
  editeur: Editeur
  errors: [CreateEditeurError!]
}

type CreateGenrePayload {
  errors: [CreateGenreError!]
  genre: Genre
}

type CreatePersonnePayload {
  errors: [CreatePersonneError!]
  personne: Personne
}

type CreateSeriePayload {
  errors: [CreateSerieError!]
  serie: Serie
}

type CreateUniversPayload {
  errors: [CreateUniversError!]
  univers: Univers
}

type DeleteAlbumPayload {
  album: Album
  errors: [DeleteAlbumError!]
}

type DeleteCollectionPayload {
  collection: Collection
  errors: [DeleteCollectionError!]
}

type DeleteEditeurPayload {
  editeur: Editeur
  errors: [DeleteEditeurError!]
}

type DeleteEditionPayload {
  edition: Edition
  errors: [DeleteEditionError!]
}

type DeleteGenrePayload {
  errors: [DeleteGenreError!]
  genre: Genre
}

type DeleteImagePayload {
  errors: [DeleteImageError!]
  image: Image
}

type DeletePersonnePayload {
  errors: [DeletePersonneError!]
  personne: Personne
}

type DeleteSeriePayload {
  errors: [DeleteSerieError!]
  serie: Serie
}

type DeleteUniversPayload {
  errors: [DeleteUniversError!]
  univers: Univers
}

type Editeur implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [NonEmptyString!]
  collections("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [CollectionSortInput!] where: CollectionFilterInput): CollectionsConnection
  createdAt: DateTime!
  editions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): EditionsConnection
  id: ID!
  initiale: Char!
  nom: NonEmptyString!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  siteWeb: URL
  updatedAt: DateTime!
}

"A connection to a list of items."
type EditeurListConnection {
  "A list of edges."
  edges: [EditeurListEdge!]
  "A flattened list of the nodes."
  nodes: [Editeur!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditeurListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Editeur!
}

type Edition implements IVersioning & IUniqueId {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): AlbumsConnection
  couleur: Boolean
  createdAt: DateTime!
  etat: Option
  formatEdition: Option
  id: ID!
  orientation: Option
  prix: EuroCurrency
  reliure: Option
  sensLecture: Option
  serie: Serie
  typeEdition: Option
  updatedAt: DateTime!
  vo: Boolean
}

type EditionAlbum implements IVersioning & IUniqueId {
  album: Album!
  anneeEdition: Year
  collection: Collection
  cotes("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [CoteSortInput!] where: CoteFilterInput): CotesConnection
  createdAt: DateTime!
  dateAchat: Date
  dedicace: Boolean
  editeur: Editeur!
  edition: Edition!
  gratuit: Boolean
  id: ID!
  images("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [ImageSortInput!] where: ImageFilterInput): ImagesConnection
  isbn: Isbn
  nombreDePages: UnsignedShort
  notes: NonEmptyString
  numeroPerso: NonEmptyString
  occasion: Boolean
  offert: Boolean
  stock: Boolean!
  updatedAt: DateTime!
}

"A connection to a list of items."
type EditionFormatEditionsConnection {
  "A list of edges."
  edges: [EditionFormatEditionsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionFormatEditionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionOrientationsConnection {
  "A list of edges."
  edges: [EditionOrientationsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionOrientationsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionReliuresConnection {
  "A list of edges."
  edges: [EditionReliuresEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionReliuresEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionSensLecturesConnection {
  "A list of edges."
  edges: [EditionSensLecturesEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionSensLecturesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionTypeEditionsConnection {
  "A list of edges."
  edges: [EditionTypeEditionsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionTypeEditionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionsConnection {
  "A list of edges."
  edges: [EditionsEdge!]
  "A flattened list of the nodes."
  nodes: [EditionAlbum!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EditionAlbum!
}

"A connection to a list of items."
type EditionsEtatsConnection {
  "A list of edges."
  edges: [EditionsEtatsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionsEtatsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

type Genre implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [NonEmptyString!]
  createdAt: DateTime!
  id: ID!
  initiale: Char!
  nom: NonEmptyString!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

type GenreAlbum implements IVersioning {
  album: Album!
  createdAt: DateTime!
  fromSerie: Boolean!
  genre: Genre!
  updatedAt: DateTime!
}

"A connection to a list of items."
type GenreListConnection {
  "A list of edges."
  edges: [GenreListEdge!]
  "A flattened list of the nodes."
  nodes: [Genre!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GenreListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Genre!
}

type GenreSerie implements IVersioning {
  createdAt: DateTime!
  genre: Genre!
  serie: Serie!
  updatedAt: DateTime!
}

"A connection to a list of items."
type GenresConnection {
  "A list of edges."
  edges: [GenresEdge!]
  "A flattened list of the nodes."
  nodes: [Genre!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GenresEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Genre!
}

type Image implements IVersioning & IUniqueId {
  createdAt: DateTime!
  edition: EditionAlbum!
  id: ID!
  ordre: UnsignedShort!
  titre: NonEmptyString
  type: Option!
  updatedAt: DateTime!
  url: URL
}

"A connection to a list of items."
type ImagesConnection {
  "A list of edges."
  edges: [ImagesEdge!]
  "A flattened list of the nodes."
  nodes: [Image!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type ImagesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Image!
}

type Mutation {
  createAlbum(input: CreateAlbumInput!): CreateAlbumPayload!
  createCollection(input: CreateCollectionInput!): CreateCollectionPayload!
  createEditeur(input: CreateEditeurInput!): CreateEditeurPayload!
  createGenre(input: CreateGenreInput!): CreateGenrePayload!
  createPersonne(input: CreatePersonneInput!): CreatePersonnePayload!
  createSerie(input: CreateSerieInput!): CreateSeriePayload!
  createUnivers(input: CreateUniversInput!): CreateUniversPayload!
  deleteAlbum(input: DeleteAlbumInput!): DeleteAlbumPayload!
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionPayload!
  deleteEditeur(input: DeleteEditeurInput!): DeleteEditeurPayload!
  deleteEdition(input: DeleteEditionInput!): DeleteEditionPayload!
  deleteGenre(input: DeleteGenreInput!): DeleteGenrePayload!
  deleteImage(input: DeleteImageInput!): DeleteImagePayload!
  deletePersonne(input: DeletePersonneInput!): DeletePersonnePayload!
  deleteSerie(input: DeleteSerieInput!): DeleteSeriePayload!
  deleteUnivers(input: DeleteUniversInput!): DeleteUniversPayload!
  updateAlbum(input: UpdateAlbumInput!): UpdateAlbumPayload!
  updateCollection(input: UpdateCollectionInput!): UpdateCollectionPayload!
  updateEditeur(input: UpdateEditeurInput!): UpdateEditeurPayload!
  updateGenre(input: UpdateGenreInput!): UpdateGenrePayload!
  updatePersonne(input: UpdatePersonneInput!): UpdatePersonnePayload!
  updateSerie(input: UpdateSerieInput!): UpdateSeriePayload!
  updateUnivers(input: UpdateUniversInput!): UpdateUniversPayload!
  uploadImagePicture(input: UploadImagePictureInput!): UploadImagePicturePayload!
}

type NotFoundIdError implements Error {
  message: String!
}

type Option implements IVersioning {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  category: OptionCategory!
  createdAt: DateTime!
  defaut: Boolean!
  editionFormatEditions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionFormatEditionsConnection
  editionOrientations("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionOrientationsConnection
  editionReliures("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionReliuresConnection
  editionSensLectures("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionSensLecturesConnection
  editionsEtats("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionsEtatsConnection
  editionTypeEditions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionTypeEditionsConnection
  id: ID!
  images("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [ImageSortInput!] where: ImageFilterInput): ImagesConnection
  libelle: NonEmptyString!
  ordre: UnsignedShort!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type OptionsConnection {
  "A list of edges."
  edges: [OptionsEdge!]
  "A flattened list of the nodes."
  nodes: [Option!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type OptionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Option!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

"A connection to a list of items."
type ParentsConnection {
  "A list of edges."
  edges: [ParentsEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type ParentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

type Personne implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [NonEmptyString!]
  biographie: NonEmptyString
  createdAt: DateTime!
  id: ID!
  initiale: Char!
  nom: NonEmptyString!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  siteWeb: URL
  updatedAt: DateTime!
}

"A connection to a list of items."
type PersonneListConnection {
  "A list of edges."
  edges: [PersonneListEdge!]
  "A flattened list of the nodes."
  nodes: [Personne!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type PersonneListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Personne!
}

type Query {
  album(where: AlbumFilterInput): Album
  albumById(id: ID!): Album!
  albumByTitre(titre: NonEmptyString!): [Album!]!
  albumList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumListConnection
  collection(where: CollectionFilterInput): Collection
  collectionById(id: ID!): Collection!
  collectionByNom(nom: NonEmptyString!): [Collection!]!
  collectionList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [CollectionSortInput!] where: CollectionFilterInput): CollectionListConnection
  editeur(where: EditeurFilterInput): Editeur
  editeurById(id: ID!): Editeur!
  editeurByNom(nom: NonEmptyString!): [Editeur!]!
  editeurList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditeurSortInput!] where: EditeurFilterInput): EditeurListConnection
  genre(where: GenreFilterInput): Genre
  genreById(id: ID!): Genre!
  genreByNom(nom: NonEmptyString!): [Genre!]!
  genreList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GenreSortInput!] where: GenreFilterInput): GenreListConnection
  optionByCategory(category: OptionCategory!): [Option!]!
  options("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [OptionSortInput!] where: OptionFilterInput): OptionsConnection
  personne(where: PersonneFilterInput): Personne
  personneById(id: ID!): Personne!
  personneByNom(nom: NonEmptyString!): [Personne!]!
  personneList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [PersonneSortInput!] where: PersonneFilterInput): PersonneListConnection
  serie(where: SerieFilterInput): Serie
  serieById(id: ID!): Serie!
  serieByTitre(titre: NonEmptyString!): [Serie!]!
  serieList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SerieListConnection
  univers(where: UniversFilterInput): Univers
  universById(id: ID!): Univers!
  universByNom(nom: NonEmptyString!): [Univers!]!
  universList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): UniversListConnection
}

"A connection to a list of items."
type RacinesConnection {
  "A list of edges."
  edges: [RacinesEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type RacinesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

type Serie implements IVersioning & IUniqueId & IAssociable & IOptionalLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [NonEmptyString!]
  auteurs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AuteurSortInput!] where: AuteurFilterInput): AuteursConnection
  collection: Collection
  complete: Boolean
  createdAt: DateTime!
  editeur: Editeur
  genres("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GenreSortInput!] where: GenreFilterInput): GenresConnection
  id: ID!
  initiale: Char
  modeleEdition: Edition!
  nbAlbums: UnsignedShort
  notation: Option
  notes: NonEmptyString
  siteWeb: URL
  suivreManquants: Boolean
  suivreSorties: Boolean
  sujet: NonEmptyString
  terminee: Boolean
  titre: NonEmptyString
  univers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): UniversConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type SerieListConnection {
  "A list of edges."
  edges: [SerieListEdge!]
  "A flattened list of the nodes."
  nodes: [Serie!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type SerieListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Serie!
}

"A connection to a list of items."
type SeriesConnection {
  "A list of edges."
  edges: [SeriesEdge!]
  "A flattened list of the nodes."
  nodes: [Serie!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type SeriesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Serie!
}

type Subscription {
  albumCreated: Album!
  albumDeleted: Album!
  albumUpdated: Album!
  collectionCreated: Collection!
  collectionDeleted: Collection!
  collectionUpdated: Collection!
  coteAlbumCreated: Cote!
  coteAlbumDeleted: Cote!
  coteAlbumUpdated: Cote!
  editeurCreated: Editeur!
  editeurDeleted: Editeur!
  editeurUpdated: Editeur!
  editionCreated: EditionAlbum!
  editionDeleted: EditionAlbum!
  editionUpdated: EditionAlbum!
  genreCreated: Genre!
  genreDeleted: Genre!
  genreUpdated: Genre!
  imageCreated: Image!
  imageDeleted: Image!
  imageUpdated: Image!
  personneCreated: Personne!
  personneDeleted: Personne!
  personneUpdated: Personne!
  serieCreated: Serie!
  serieDeleted: Serie!
  serieUpdated: Serie!
  universCreated: Univers!
  universDeleted: Univers!
  universUpdated: Univers!
}

type Univers implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [NonEmptyString!]
  branche: [UUID!]
  createdAt: DateTime!
  description: NonEmptyString
  id: ID!
  initiale: Char!
  nom: NonEmptyString!
  parent: Univers
  parents("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): ParentsConnection
  racine: Univers!
  racines("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): RacinesConnection
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  siteWeb: URL
  updatedAt: DateTime!
}

type UniversAlbum implements IVersioning {
  album: Album!
  createdAt: DateTime!
  fromSerie: Boolean!
  univers: Univers!
  updatedAt: DateTime!
}

"A connection to a list of items."
type UniversConnection {
  "A list of edges."
  edges: [UniversEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type UniversEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

"A connection to a list of items."
type UniversListConnection {
  "A list of edges."
  edges: [UniversListEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type UniversListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

type UniversSerie implements IVersioning {
  createdAt: DateTime!
  serie: Serie!
  univers: Univers!
  updatedAt: DateTime!
}

type UpdateAlbumPayload {
  album: Album
  errors: [UpdateAlbumError!]
}

type UpdateCollectionPayload {
  collection: Collection
  errors: [UpdateCollectionError!]
}

type UpdateEditeurPayload {
  editeur: Editeur
  errors: [UpdateEditeurError!]
}

type UpdateGenrePayload {
  errors: [UpdateGenreError!]
  genre: Genre
}

type UpdatePersonnePayload {
  errors: [UpdatePersonneError!]
  personne: Personne
}

type UpdateSeriePayload {
  errors: [UpdateSerieError!]
  serie: Serie
}

type UpdateUniversPayload {
  errors: [UpdateUniversError!]
  univers: Univers
}

type UploadImagePicturePayload {
  image: Image
}

union CreateAlbumError = AlreadyExistsError

union CreateCollectionError = AlreadyExistsError

union CreateEditeurError = AlreadyExistsError

union CreateGenreError = AlreadyExistsError

union CreatePersonneError = AlreadyExistsError

union CreateSerieError = AlreadyExistsError

union CreateUniversError = AlreadyExistsError

union DeleteAlbumError = NotFoundIdError

union DeleteCollectionError = NotFoundIdError

union DeleteEditeurError = NotFoundIdError

union DeleteEditionError = NotFoundIdError

union DeleteGenreError = NotFoundIdError

union DeleteImageError = NotFoundIdError

union DeletePersonneError = NotFoundIdError

union DeleteSerieError = NotFoundIdError

union DeleteUniversError = NotFoundIdError

union UpdateAlbumError = AlreadyExistsError | NotFoundIdError

union UpdateCollectionError = AlreadyExistsError | NotFoundIdError

union UpdateEditeurError = AlreadyExistsError | NotFoundIdError

union UpdateGenreError = AlreadyExistsError | NotFoundIdError

union UpdatePersonneError = AlreadyExistsError | NotFoundIdError

union UpdateSerieError = AlreadyExistsError | NotFoundIdError

union UpdateUniversError = AlreadyExistsError | NotFoundIdError

input AlbumCreateInput {
  anneeParution: Year
  associations: [NonEmptyString!]
  horsSerie: Boolean
  integrale: Boolean
  moisParution: Month
  notation: Notation
  notes: NonEmptyString
  serie: SerieNestedInput
  sujet: NonEmptyString
  titre: NonEmptyString
  tome: UnsignedShort
  tomeDebut: UnsignedShort
  tomeFin: UnsignedShort
}

input AlbumFilterInput {
  and: [AlbumFilterInput!]
  or: [AlbumFilterInput!]
  titre: StringOperationFilterInput
  sujet: StringOperationFilterInput
  notes: StringOperationFilterInput
  horsSerie: BooleanOperationFilterInput
  tome: ComparableUnsignedShortTypeOperationFilterInput
  integrale: BooleanOperationFilterInput
  tomeDebut: ComparableUnsignedShortTypeOperationFilterInput
  tomeFin: ComparableUnsignedShortTypeOperationFilterInput
  moisParution: ComparableUnsignedShortTypeOperationFilterInput
  anneeParution: ComparableUnsignedShortTypeOperationFilterInput
  serie: SerieFilterInput
  notation: OptionFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input AlbumSortInput {
  titre: SortEnumType
  titreRaw: SortEnumType
  sujet: SortEnumType
  sujetRaw: SortEnumType
  notes: SortEnumType
  notesRaw: SortEnumType
  horsSerie: SortEnumType
  tome: SortEnumType
  integrale: SortEnumType
  tomeDebut: SortEnumType
  tomeFin: SortEnumType
  moisParution: SortEnumType
  anneeParution: SortEnumType
  serieId: SortEnumType
  serie: SerieSortInput
  notationId: SortEnumType
  notation: OptionSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input AlbumUpdateInput {
  anneeParution: Year
  associations: [NonEmptyString!]
  horsSerie: Boolean
  id: ID!
  integrale: Boolean
  moisParution: Month
  notation: Notation
  notes: NonEmptyString
  serie: SerieNestedInput
  sujet: NonEmptyString
  titre: NonEmptyString
  tome: UnsignedShort
  tomeDebut: UnsignedShort
  tomeFin: UnsignedShort
}

input AuteurFilterInput {
  and: [AuteurFilterInput!]
  or: [AuteurFilterInput!]
  personne: PersonneFilterInput
  metier: MetierOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input AuteurSortInput {
  personneId: SortEnumType
  personne: PersonneSortInput
  metier: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input CharOperationFilterInput {
  and: [CharOperationFilterInput!]
  or: [CharOperationFilterInput!]
  eq: Char
  neq: Char
  in: [Char]
  nin: [Char]
}

input CollectionCreateInput {
  associations: [NonEmptyString!]
  editeur: EditeurNestedInput!
  nom: NonEmptyString!
}

input CollectionFilterInput {
  and: [CollectionFilterInput!]
  or: [CollectionFilterInput!]
  nom: StringOperationFilterInput
  editeur: EditeurFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input CollectionNestedInput {
  id: ID!
}

input CollectionSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  editeurId: SortEnumType
  editeur: EditeurSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input CollectionUpdateInput {
  associations: [NonEmptyString!]
  editeur: EditeurNestedInput!
  id: ID!
  nom: NonEmptyString!
}

input ComparableNonNullTypeOfUnsignedShortTypeOperationFilterInput {
  eq: UnsignedShort
  neq: UnsignedShort
  in: [UnsignedShort!]
  nin: [UnsignedShort!]
  gt: UnsignedShort
  ngt: UnsignedShort
  gte: UnsignedShort
  ngte: UnsignedShort
  lt: UnsignedShort
  nlt: UnsignedShort
  lte: UnsignedShort
  nlte: UnsignedShort
}

input ComparableUnsignedShortTypeOperationFilterInput {
  eq: UnsignedShort
  neq: UnsignedShort
  in: [UnsignedShort]
  nin: [UnsignedShort]
  gt: UnsignedShort
  ngt: UnsignedShort
  gte: UnsignedShort
  ngte: UnsignedShort
  lt: UnsignedShort
  nlt: UnsignedShort
  lte: UnsignedShort
  nlte: UnsignedShort
}

input CoteFilterInput {
  and: [CoteFilterInput!]
  or: [CoteFilterInput!]
  editionAlbum: EditionAlbumFilterInput
  annee: ComparableNonNullTypeOfUnsignedShortTypeOperationFilterInput
  prix: DecimalOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input CoteSortInput {
  editionAlbumId: SortEnumType
  editionAlbum: EditionAlbumSortInput
  annee: SortEnumType
  prix: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input CreateAlbumInput {
  album: AlbumCreateInput!
}

input CreateCollectionInput {
  collection: CollectionCreateInput!
}

input CreateEditeurInput {
  editeur: EditeurCreateInput!
}

input CreateGenreInput {
  genre: GenreCreateInput!
}

input CreatePersonneInput {
  personne: PersonneCreateInput!
}

input CreateSerieInput {
  serie: SerieCreateInput!
}

input CreateUniversInput {
  univers: UniversCreateInput!
}

input DateOperationFilterInput {
  eq: Date
  neq: Date
  in: [Date]
  nin: [Date]
  gt: Date
  ngt: Date
  gte: Date
  ngte: Date
  lt: Date
  nlt: Date
  lte: Date
  nlte: Date
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input DecimalOperationFilterInput {
  eq: Decimal
  neq: Decimal
  in: [Decimal]
  nin: [Decimal]
  gt: Decimal
  ngt: Decimal
  gte: Decimal
  ngte: Decimal
  lt: Decimal
  nlt: Decimal
  lte: Decimal
  nlte: Decimal
}

input DeleteAlbumInput {
  id: ID!
}

input DeleteCollectionInput {
  id: ID!
}

input DeleteEditeurInput {
  id: ID!
}

input DeleteEditionInput {
  id: ID!
}

input DeleteGenreInput {
  id: ID!
}

input DeleteImageInput {
  id: ID!
}

input DeletePersonneInput {
  id: ID!
}

input DeleteSerieInput {
  id: ID!
}

input DeleteUniversInput {
  id: ID!
}

input EditeurCreateInput {
  associations: [NonEmptyString!]
  nom: NonEmptyString!
  siteWeb: URL
}

input EditeurFilterInput {
  and: [EditeurFilterInput!]
  or: [EditeurFilterInput!]
  nom: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input EditeurNestedInput {
  id: ID!
}

input EditeurSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  siteWeb: UriSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input EditeurUpdateInput {
  associations: [NonEmptyString!]
  id: ID!
  nom: NonEmptyString!
  siteWeb: URL
}

input EditionAlbumFilterInput {
  and: [EditionAlbumFilterInput!]
  or: [EditionAlbumFilterInput!]
  edition: EditionFilterInput
  album: AlbumFilterInput
  editeur: EditeurFilterInput
  collection: CollectionFilterInput
  anneeEdition: ComparableUnsignedShortTypeOperationFilterInput
  isbn: StringOperationFilterInput
  nombreDePages: ComparableUnsignedShortTypeOperationFilterInput
  stock: BooleanOperationFilterInput
  offert: BooleanOperationFilterInput
  occasion: BooleanOperationFilterInput
  gratuit: BooleanOperationFilterInput
  dateAchat: DateOperationFilterInput
  dedicace: BooleanOperationFilterInput
  numeroPerso: StringOperationFilterInput
  notes: StringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input EditionAlbumSortInput {
  editionId: SortEnumType
  edition: EditionSortInput
  albumId: SortEnumType
  album: AlbumSortInput
  editeurId: SortEnumType
  editeur: EditeurSortInput
  collectionId: SortEnumType
  collection: CollectionSortInput
  anneeEdition: SortEnumType
  isbn: SortEnumType
  nombreDePages: SortEnumType
  stock: SortEnumType
  offert: SortEnumType
  occasion: SortEnumType
  gratuit: SortEnumType
  dateAchat: SortEnumType
  dedicace: SortEnumType
  numeroPerso: SortEnumType
  notes: SortEnumType
  notesRaw: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input EditionFilterInput {
  and: [EditionFilterInput!]
  or: [EditionFilterInput!]
  prix: DecimalOperationFilterInput
  couleur: BooleanOperationFilterInput
  vo: BooleanOperationFilterInput
  etat: OptionFilterInput
  reliure: OptionFilterInput
  formatEdition: OptionFilterInput
  typeEdition: OptionFilterInput
  orientation: OptionFilterInput
  sensLecture: OptionFilterInput
  serie: SerieFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input EditionNestedInput {
  id: ID!
}

input EditionSortInput {
  prix: SortEnumType
  couleur: SortEnumType
  vo: SortEnumType
  etatId: SortEnumType
  etat: OptionSortInput
  reliureId: SortEnumType
  reliure: OptionSortInput
  formatEditionId: SortEnumType
  formatEdition: OptionSortInput
  typeEditionId: SortEnumType
  typeEdition: OptionSortInput
  orientationId: SortEnumType
  orientation: OptionSortInput
  sensLectureId: SortEnumType
  sensLecture: OptionSortInput
  serie: SerieSortInput
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input GenreCreateInput {
  associations: [NonEmptyString!]
  nom: NonEmptyString!
}

input GenreFilterInput {
  and: [GenreFilterInput!]
  or: [GenreFilterInput!]
  nom: StringOperationFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input GenreSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input GenreUpdateInput {
  associations: [NonEmptyString!]
  id: ID!
  nom: NonEmptyString!
}

input IdOperationFilterInput {
  eq: ID
  neq: ID
  in: [ID]
  nin: [ID]
}

input ImageFilterInput {
  and: [ImageFilterInput!]
  or: [ImageFilterInput!]
  titre: StringOperationFilterInput
  ordre: ComparableNonNullTypeOfUnsignedShortTypeOperationFilterInput
  type: OptionFilterInput
  edition: EditionAlbumFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input ImageSortInput {
  titre: SortEnumType
  ordre: SortEnumType
  typeId: SortEnumType
  type: OptionSortInput
  editionId: SortEnumType
  edition: EditionAlbumSortInput
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  none: StringOperationFilterInput
  some: StringOperationFilterInput
  any: Boolean
}

input MetierOperationFilterInput {
  eq: Metier
  neq: Metier
  in: [Metier!]
  nin: [Metier!]
}

input OptionCategoryOperationFilterInput {
  eq: OptionCategory
  neq: OptionCategory
  in: [OptionCategory!]
  nin: [OptionCategory!]
}

input OptionFilterInput {
  and: [OptionFilterInput!]
  or: [OptionFilterInput!]
  id: IdOperationFilterInput
  category: OptionCategoryOperationFilterInput
  libelle: StringOperationFilterInput
  ordre: ComparableNonNullTypeOfUnsignedShortTypeOperationFilterInput
  defaut: BooleanOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input OptionSortInput {
  id: SortEnumType
  category: SortEnumType
  libelle: SortEnumType
  ordre: SortEnumType
  defaut: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input PersonneCreateInput {
  associations: [NonEmptyString!]
  biographie: NonEmptyString
  nom: NonEmptyString!
  siteWeb: URL
}

input PersonneFilterInput {
  and: [PersonneFilterInput!]
  or: [PersonneFilterInput!]
  nom: StringOperationFilterInput
  biographie: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input PersonneSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  biographie: SortEnumType
  biographieRaw: SortEnumType
  siteWeb: UriSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input PersonneUpdateInput {
  associations: [NonEmptyString!]
  biographie: NonEmptyString
  id: ID!
  nom: NonEmptyString!
  siteWeb: URL
}

input SerieCreateInput {
  associations: [NonEmptyString!]
  collection: CollectionNestedInput
  complete: Boolean
  editeur: EditeurNestedInput
  modeleEdition: EditionNestedInput!
  nbAlbums: UnsignedShort
  notation: Notation
  notes: NonEmptyString
  siteWeb: URL
  suivreManquants: Boolean
  suivreSorties: Boolean
  sujet: NonEmptyString
  terminee: Boolean
  titre: NonEmptyString
}

input SerieFilterInput {
  and: [SerieFilterInput!]
  or: [SerieFilterInput!]
  titre: StringOperationFilterInput
  sujet: StringOperationFilterInput
  notes: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  editeur: EditeurFilterInput
  collection: CollectionFilterInput
  modeleEdition: EditionFilterInput
  nbAlbums: ComparableUnsignedShortTypeOperationFilterInput
  terminee: BooleanOperationFilterInput
  complete: BooleanOperationFilterInput
  suivreSorties: BooleanOperationFilterInput
  suivreManquants: BooleanOperationFilterInput
  notation: OptionFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input SerieNestedInput {
  id: ID!
}

input SerieSortInput {
  titre: SortEnumType
  titreRaw: SortEnumType
  sujet: SortEnumType
  sujetRaw: SortEnumType
  notes: SortEnumType
  notesRaw: SortEnumType
  siteWeb: UriSortInput
  editeurId: SortEnumType
  editeur: EditeurSortInput
  collectionId: SortEnumType
  collection: CollectionSortInput
  modeleEditionId: SortEnumType
  modeleEdition: EditionSortInput
  nbAlbums: SortEnumType
  terminee: SortEnumType
  complete: SortEnumType
  suivreSorties: SortEnumType
  suivreManquants: SortEnumType
  notationId: SortEnumType
  notation: OptionSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input SerieUpdateInput {
  associations: [NonEmptyString!]
  collection: CollectionNestedInput
  complete: Boolean
  editeur: EditeurNestedInput
  id: ID!
  modeleEdition: EditionNestedInput!
  nbAlbums: UnsignedShort
  notation: Notation
  notes: NonEmptyString
  siteWeb: URL
  suivreManquants: Boolean
  suivreSorties: Boolean
  sujet: NonEmptyString
  terminee: Boolean
  titre: NonEmptyString
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input UniversCreateInput {
  associations: [NonEmptyString!]
  description: NonEmptyString
  nom: NonEmptyString!
  parent: UniversNestedInput
  racine: UniversNestedInput!
  siteWeb: URL
}

input UniversFilterInput {
  and: [UniversFilterInput!]
  or: [UniversFilterInput!]
  nom: StringOperationFilterInput
  description: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  racine: UniversFilterInput
  parent: UniversFilterInput
  initiale: CharOperationFilterInput
  associations: ListStringOperationFilterInput
  id: IdOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input UniversNestedInput {
  id: ID!
}

input UniversSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  description: SortEnumType
  descriptionRaw: SortEnumType
  siteWeb: UriSortInput
  universRacineId: SortEnumType
  racine: UniversSortInput
  universParentId: SortEnumType
  parent: UniversSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input UniversUpdateInput {
  associations: [NonEmptyString!]
  description: NonEmptyString
  id: ID!
  nom: NonEmptyString!
  parent: UniversNestedInput
  racine: UniversNestedInput!
  siteWeb: URL
}

input UpdateAlbumInput {
  album: AlbumUpdateInput!
}

input UpdateCollectionInput {
  collection: CollectionUpdateInput!
}

input UpdateEditeurInput {
  editeur: EditeurUpdateInput!
}

input UpdateGenreInput {
  genre: GenreUpdateInput!
}

input UpdatePersonneInput {
  personne: PersonneUpdateInput!
}

input UpdateSerieInput {
  serie: SerieUpdateInput!
}

input UpdateUniversInput {
  univers: UniversUpdateInput!
}

input UploadImagePictureInput {
  file: Upload
  id: ID!
}

input UriSortInput {
  absolutePath: SortEnumType
  absoluteUri: SortEnumType
  localPath: SortEnumType
  authority: SortEnumType
  hostNameType: SortEnumType
  isDefaultPort: SortEnumType
  isFile: SortEnumType
  isLoopback: SortEnumType
  pathAndQuery: SortEnumType
  isUnc: SortEnumType
  host: SortEnumType
  port: SortEnumType
  query: SortEnumType
  fragment: SortEnumType
  scheme: SortEnumType
  originalString: SortEnumType
  dnsSafeHost: SortEnumType
  idnHost: SortEnumType
  isAbsoluteUri: SortEnumType
  userEscaped: SortEnumType
  userInfo: SortEnumType
}

input UrlOperationFilterInput {
  eq: URL
  neq: URL
  in: [URL]
  nin: [URL]
  gt: URL
  ngt: URL
  gte: URL
  ngte: URL
  lt: URL
  nlt: URL
  lte: URL
  nlte: URL
}

enum Metier {
  SCENARISTE
  DESSINATEUR
  COLORISTE
}

enum OptionCategory {
  EDITION_ETAT
  EDITION_RELIURE
  EDITION_TYPE
  EDITION_ORIENTATION
  EDITION_FORMAT
  IMAGE_TYPE
  EDITION_SENS_LECTURE
  NOTATION
}

enum SortEnumType {
  ASC
  DESC
}

directive @nullBubbling(enable: Boolean! = true) on QUERY | MUTATION | SUBSCRIPTION

scalar Char

"The `Date` scalar represents an ISO-8601 compliant date type."
scalar Date

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The built-in `Decimal` scalar type."
scalar Decimal

"Integers that will represent a book condition.\nValid values: [100, 103, 105, 108, 110]"
scalar EditionEtat

"Integers that will represent a book edition format.\nValid values: [501, 503, 504, 505, 506, 510]"
scalar EditionFormat

"Integers that will represent a book edition orientation.\nValid values: [401, 402]"
scalar EditionOrientation

"Integers that will represent a book binding.\nValid values: [200, 201]"
scalar EditionReliure

"Integers that will represent a book reading direction.\nValid values: [801, 802]"
scalar EditionSensLecture

"Integers that will represent a book edition kind.\nValid values: [301, 302, 303]"
scalar EditionType

scalar EuroCurrency

"Integers that will represent an image kind.\nValid values: [600, 601, 602, 603, 604]"
scalar ImageType

"The ISBN scalar type is a ISBN-10 or ISBN-13 number: https:\/\/en.wikipedia.org\/wiki\/International_Standard_Book_Number."
scalar Isbn

"Value between 1 and 12"
scalar Month

"The NonEmptyString scalar type represents non empty textual data, represented as UTF‐8 character sequences with at least one character"
scalar NonEmptyString

"Integers that will represent a notation.\nValid values: [900, 901, 902, 903, 904, 905]"
scalar Notation

scalar URL @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc3986")

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")

"The UnsignedShort scalar type represents a unsigned 16-bit numeric non-fractional value greater than or equal to 0."
scalar UnsignedShort

"The `Upload` scalar type represents a file upload."
scalar Upload

"Value between 1900 and 2999"
scalar Year
