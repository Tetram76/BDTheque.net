schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface Error {
  message: String!
}

interface IAssociable {
  associations: [String!]!
}

interface IMandatoryLabel {
  initiale: String!
}

interface IOptionalLabel {
  initiale: String
}

interface ISimpleId {
  id: ID!
}

interface IUniqueId {
  id: ID!
}

interface IVersioning {
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Album implements IVersioning & IUniqueId & IAssociable & IOptionalLabel {
  anneeParution: Year
  associations: [String!]!
  auteurs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AuteurSortInput!] where: AuteurFilterInput): AuteursConnection
  createdAt: DateTime!
  editions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): EditionsConnection
  genres("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GenreSortInput!] where: GenreFilterInput): GenresConnection
  horsSerie: Boolean
  id: ID!
  initiale: String
  integrale: Boolean
  moisParution: Month
  notation: Option
  notes: String
  serie: Serie
  sujet: String
  titre: String
  tome: UnsignedShort
  tomeDebut: UnsignedShort
  tomeFin: UnsignedShort
  univers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): UniversConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type AlbumListConnection {
  "A list of edges."
  edges: [AlbumListEdge!]
  "A flattened list of the nodes."
  nodes: [Album!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type AlbumListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Album!
}

"A connection to a list of items."
type AlbumsConnection {
  "A list of edges."
  edges: [AlbumsEdge!]
  "A flattened list of the nodes."
  nodes: [Album!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type AlbumsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Album!
}

type AlreadyExistsError implements Error {
  message: String!
}

type Auteur implements IVersioning & IUniqueId {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  createdAt: DateTime!
  id: ID!
  metier: Metier!
  personne: Personne!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

type AuteurAlbum implements IVersioning & IUniqueId {
  album: Album!
  auteur: Auteur!
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

type AuteurSerie implements IVersioning & IUniqueId {
  auteur: Auteur!
  createdAt: DateTime!
  id: ID!
  serie: Serie!
  updatedAt: DateTime!
}

"A connection to a list of items."
type AuteursConnection {
  "A list of edges."
  edges: [AuteursEdge!]
  "A flattened list of the nodes."
  nodes: [Auteur!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type AuteursEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Auteur!
}

type Collection implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): AlbumsConnection
  associations: [String!]!
  createdAt: DateTime!
  editeur: Editeur!
  id: ID!
  initiale: String!
  nom: String!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type CollectionListConnection {
  "A list of edges."
  edges: [CollectionListEdge!]
  "A flattened list of the nodes."
  nodes: [Collection!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type CollectionListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Collection!
}

"A connection to a list of items."
type CollectionsConnection {
  "A list of edges."
  edges: [CollectionsEdge!]
  "A flattened list of the nodes."
  nodes: [Collection!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type CollectionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Collection!
}

type Cote implements IVersioning & IUniqueId {
  annee: Year
  createdAt: DateTime!
  editionAlbum: EditionAlbum!
  id: ID!
  prix: EuroCurrency
  updatedAt: DateTime!
}

"A connection to a list of items."
type CotesConnection {
  "A list of edges."
  edges: [CotesEdge!]
  "A flattened list of the nodes."
  nodes: [Cote!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type CotesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Cote!
}

type CreateGenrePayload {
  errors: [CreateGenreError!]
  genre: Genre
}

type DeleteAlbumPayload {
  album: Album
  errors: [DeleteAlbumError!]
}

type DeleteCollectionPayload {
  collection: Collection
  errors: [DeleteCollectionError!]
}

type DeleteEditeurPayload {
  editeur: Editeur
  errors: [DeleteEditeurError!]
}

type DeleteEditionPayload {
  edition: Edition
  errors: [DeleteEditionError!]
}

type DeleteGenrePayload {
  errors: [DeleteGenreError!]
  genre: Genre
}

type DeleteImagePayload {
  errors: [DeleteImageError!]
  image: Image
}

type DeletePersonnePayload {
  errors: [DeletePersonneError!]
  personne: Personne
}

type DeleteSeriePayload {
  errors: [DeleteSerieError!]
  serie: Serie
}

type DeleteUniversPayload {
  errors: [DeleteUniversError!]
  univers: Univers
}

type Editeur implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [String!]!
  collections("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [CollectionSortInput!] where: CollectionFilterInput): CollectionsConnection
  createdAt: DateTime!
  editions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): EditionsConnection
  id: ID!
  initiale: String!
  nom: String!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  siteWeb: URL
  updatedAt: DateTime!
}

"A connection to a list of items."
type EditeurListConnection {
  "A list of edges."
  edges: [EditeurListEdge!]
  "A flattened list of the nodes."
  nodes: [Editeur!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditeurListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Editeur!
}

type Edition implements IVersioning & IUniqueId {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): AlbumsConnection
  anneeEdition: Year
  couleur: Boolean
  createdAt: DateTime!
  formatEdition: Option
  id: ID!
  isbn: Isbn
  nombreDePages: UnsignedShort
  notes: String
  orientation: Option
  reliure: Option
  sensLecture: Option
  serie: Serie
  typeEdition: Option
  updatedAt: DateTime!
  vo: Boolean
}

type EditionAlbum implements IVersioning & IUniqueId {
  album: Album!
  collection: Collection
  cotes("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [CoteSortInput!] where: CoteFilterInput): CotesConnection
  createdAt: DateTime!
  dateAchat: Date
  dedicace: Boolean
  editeur: Editeur!
  edition: Edition!
  etat: Option
  gratuit: Boolean
  id: ID!
  images("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [ImageSortInput!] where: ImageFilterInput): ImagesConnection
  notes: String
  numeroPerso: String
  occasion: Boolean
  offert: Boolean
  prix: EuroCurrency
  stock: Boolean!
  updatedAt: DateTime!
}

"A connection to a list of items."
type EditionFormatEditionsConnection {
  "A list of edges."
  edges: [EditionFormatEditionsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionFormatEditionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionOrientationsConnection {
  "A list of edges."
  edges: [EditionOrientationsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionOrientationsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionReliuresConnection {
  "A list of edges."
  edges: [EditionReliuresEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionReliuresEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionSensLecturesConnection {
  "A list of edges."
  edges: [EditionSensLecturesEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionSensLecturesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionTypeEditionsConnection {
  "A list of edges."
  edges: [EditionTypeEditionsEdge!]
  "A flattened list of the nodes."
  nodes: [Edition!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionTypeEditionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Edition!
}

"A connection to a list of items."
type EditionsAlbumsConnection {
  "A list of edges."
  edges: [EditionsAlbumsEdge!]
  "A flattened list of the nodes."
  nodes: [EditionAlbum!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionsAlbumsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EditionAlbum!
}

"A connection to a list of items."
type EditionsConnection {
  "A list of edges."
  edges: [EditionsEdge!]
  "A flattened list of the nodes."
  nodes: [EditionAlbum!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type EditionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EditionAlbum!
}

type Genre implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [String!]!
  createdAt: DateTime!
  id: ID!
  initiale: String!
  nom: String!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

type GenreAlbum implements IVersioning & IUniqueId {
  album: Album!
  createdAt: DateTime!
  fromSerie: Boolean!
  genre: Genre!
  id: ID!
  updatedAt: DateTime!
}

"A connection to a list of items."
type GenreListConnection {
  "A list of edges."
  edges: [GenreListEdge!]
  "A flattened list of the nodes."
  nodes: [Genre!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GenreListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Genre!
}

type GenreSerie implements IVersioning & IUniqueId {
  createdAt: DateTime!
  genre: Genre!
  id: ID!
  serie: Serie!
  updatedAt: DateTime!
}

"A connection to a list of items."
type GenresConnection {
  "A list of edges."
  edges: [GenresEdge!]
  "A flattened list of the nodes."
  nodes: [Genre!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type GenresEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Genre!
}

type Image implements IVersioning & IUniqueId {
  createdAt: DateTime!
  edition: EditionAlbum!
  id: ID!
  ordre: UnsignedShort!
  titre: String
  type: Option!
  updatedAt: DateTime!
  url: URL
}

"A connection to a list of items."
type ImagesConnection {
  "A list of edges."
  edges: [ImagesEdge!]
  "A flattened list of the nodes."
  nodes: [Image!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type ImagesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Image!
}

type Mutation {
  createGenre(input: CreateGenreInput!): CreateGenrePayload!
  deleteAlbum(input: DeleteAlbumInput!): DeleteAlbumPayload!
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionPayload!
  deleteEditeur(input: DeleteEditeurInput!): DeleteEditeurPayload!
  deleteEdition(input: DeleteEditionInput!): DeleteEditionPayload!
  deleteGenre(input: DeleteGenreInput!): DeleteGenrePayload!
  deleteImage(input: DeleteImageInput!): DeleteImagePayload!
  deletePersonne(input: DeletePersonneInput!): DeletePersonnePayload!
  deleteSerie(input: DeleteSerieInput!): DeleteSeriePayload!
  deleteUnivers(input: DeleteUniversInput!): DeleteUniversPayload!
  updateGenre(input: UpdateGenreInput!): UpdateGenrePayload!
  uploadImagePicture(input: UploadImagePictureInput!): UploadImagePicturePayload!
}

type NotFoundIdError implements Error {
  message: String!
}

type Option implements IVersioning & ISimpleId {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  category: ID!
  createdAt: DateTime!
  defaut: Boolean!
  editionFormatEditions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionFormatEditionsConnection
  editionOrientations("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionOrientationsConnection
  editionReliures("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionReliuresConnection
  editionsAlbums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionAlbumSortInput!] where: EditionAlbumFilterInput): EditionsAlbumsConnection
  editionSensLectures("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionSensLecturesConnection
  editionTypeEditions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditionSortInput!] where: EditionFilterInput): EditionTypeEditionsConnection
  id: ID!
  images("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [ImageSortInput!] where: ImageFilterInput): ImagesConnection
  libelle: String!
  ordre: UnsignedShort!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type OptionsConnection {
  "A list of edges."
  edges: [OptionsEdge!]
  "A flattened list of the nodes."
  nodes: [Option!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type OptionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Option!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

"A connection to a list of items."
type ParentsConnection {
  "A list of edges."
  edges: [ParentsEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type ParentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

type Personne implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [String!]!
  biographie: String
  createdAt: DateTime!
  id: ID!
  initiale: String!
  nom: String!
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  siteWeb: URL
  updatedAt: DateTime!
}

"A connection to a list of items."
type PersonneListConnection {
  "A list of edges."
  edges: [PersonneListEdge!]
  "A flattened list of the nodes."
  nodes: [Personne!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type PersonneListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Personne!
}

type Query {
  album(where: AlbumFilterInput): Album
  albumById(id: ID!): Album!
  albumByTitre(titre: String!): [Album!]!
  albumList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumListConnection
  collection(where: CollectionFilterInput): Collection
  collectionById(id: ID!): Collection!
  collectionByNom(nom: String!): [Collection!]!
  collectionList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [CollectionSortInput!] where: CollectionFilterInput): CollectionListConnection
  editeur(where: EditeurFilterInput): Editeur
  editeurById(id: ID!): Editeur!
  editeurByNom(nom: String!): [Editeur!]!
  editeurList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [EditeurSortInput!] where: EditeurFilterInput): EditeurListConnection
  genre(where: GenreFilterInput): Genre
  genreById(id: ID!): Genre!
  genreByNom(nom: String!): [Genre!]!
  genreList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GenreSortInput!] where: GenreFilterInput): GenreListConnection
  optionByCategory(category: OptionCategory!): [Option!]!
  options("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [OptionSortInput!] where: OptionFilterInput): OptionsConnection
  personne(where: PersonneFilterInput): Personne
  personneById(id: ID!): Personne!
  personneByNom(nom: String!): [Personne!]!
  personneList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [PersonneSortInput!] where: PersonneFilterInput): PersonneListConnection
  serie(where: SerieFilterInput): Serie
  serieById(id: ID!): Serie!
  serieByTitre(titre: String!): [Serie!]!
  serieList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SerieListConnection
  univers(where: UniversFilterInput): Univers
  universById(id: ID!): Univers!
  universByNom(nom: String!): [Univers!]!
  universList("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): UniversListConnection
}

"A connection to a list of items."
type RacinesConnection {
  "A list of edges."
  edges: [RacinesEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type RacinesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

type Serie implements IVersioning & IUniqueId & IAssociable & IOptionalLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [String!]!
  auteurs("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AuteurSortInput!] where: AuteurFilterInput): AuteursConnection
  collection: Collection
  complete: Boolean
  createdAt: DateTime!
  editeur: Editeur
  genres("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GenreSortInput!] where: GenreFilterInput): GenresConnection
  id: ID!
  initiale: String
  modeleEdition: Edition!
  nbAlbums: UnsignedShort
  notation: Option
  notes: String
  siteWeb: URL
  suivreManquants: Boolean
  suivreSorties: Boolean
  sujet: String
  terminee: Boolean
  titre: String
  univers("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): UniversConnection
  updatedAt: DateTime!
}

"A connection to a list of items."
type SerieListConnection {
  "A list of edges."
  edges: [SerieListEdge!]
  "A flattened list of the nodes."
  nodes: [Serie!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type SerieListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Serie!
}

"A connection to a list of items."
type SeriesConnection {
  "A list of edges."
  edges: [SeriesEdge!]
  "A flattened list of the nodes."
  nodes: [Serie!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type SeriesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Serie!
}

type Subscription {
  albumCreated: Album!
  albumDeleted: Album!
  albumUpdated: Album!
  collectionCreated: Collection!
  collectionDeleted: Collection!
  collectionUpdated: Collection!
  coteAlbumCreated: Cote!
  coteAlbumDeleted: Cote!
  coteAlbumUpdated: Cote!
  editeurCreated: Editeur!
  editeurDeleted: Editeur!
  editeurUpdated: Editeur!
  editionCreated: EditionAlbum!
  editionDeleted: EditionAlbum!
  editionUpdated: EditionAlbum!
  genreCreated: Genre!
  genreDeleted: Genre!
  genreUpdated: Genre!
  imageCreated: Image!
  imageDeleted: Image!
  imageUpdated: Image!
  personneCreated: Personne!
  personneDeleted: Personne!
  personneUpdated: Personne!
  serieCreated: Serie!
  serieDeleted: Serie!
  serieUpdated: Serie!
  universCreated: Univers!
  universDeleted: Univers!
  universUpdated: Univers!
}

type Univers implements IVersioning & IUniqueId & IAssociable & IMandatoryLabel {
  albums("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [AlbumSortInput!] where: AlbumFilterInput): AlbumsConnection
  associations: [String!]!
  branche: [UUID!]
  createdAt: DateTime!
  description: String
  id: ID!
  initiale: String!
  nom: String!
  parent: Univers
  parents("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): ParentsConnection
  racine: Univers!
  racines("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UniversSortInput!] where: UniversFilterInput): RacinesConnection
  series("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [SerieSortInput!] where: SerieFilterInput): SeriesConnection
  siteWeb: URL
  updatedAt: DateTime!
}

type UniversAlbum implements IVersioning & IUniqueId {
  album: Album!
  createdAt: DateTime!
  fromSerie: Boolean!
  id: ID!
  univers: Univers!
  updatedAt: DateTime!
}

"A connection to a list of items."
type UniversConnection {
  "A list of edges."
  edges: [UniversEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type UniversEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

"A connection to a list of items."
type UniversListConnection {
  "A list of edges."
  edges: [UniversListEdge!]
  "A flattened list of the nodes."
  nodes: [Univers!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type UniversListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Univers!
}

type UniversSerie implements IVersioning & IUniqueId {
  createdAt: DateTime!
  id: ID!
  serie: Serie!
  univers: Univers!
  updatedAt: DateTime!
}

type UpdateGenrePayload {
  errors: [UpdateGenreError!]
  genre: Genre
}

type UploadImagePicturePayload {
  image: Image
}

union CreateGenreError = AlreadyExistsError

union DeleteAlbumError = NotFoundIdError

union DeleteCollectionError = NotFoundIdError

union DeleteEditeurError = NotFoundIdError

union DeleteEditionError = NotFoundIdError

union DeleteGenreError = NotFoundIdError

union DeleteImageError = NotFoundIdError

union DeletePersonneError = NotFoundIdError

union DeleteSerieError = NotFoundIdError

union DeleteUniversError = NotFoundIdError

union UpdateGenreError = AlreadyExistsError | NotFoundIdError

input AlbumFilterInput {
  and: [AlbumFilterInput!]
  or: [AlbumFilterInput!]
  titre: StringOperationFilterInput
  sujet: StringOperationFilterInput
  notes: StringOperationFilterInput
  horsSerie: BooleanOperationFilterInput
  tome: ComparableUnsignedIntTypeOperationFilterInput
  integrale: BooleanOperationFilterInput
  tomeDebut: ComparableUnsignedIntTypeOperationFilterInput
  tomeFin: ComparableUnsignedIntTypeOperationFilterInput
  moisParution: ComparableUnsignedIntTypeOperationFilterInput
  anneeParution: ComparableUnsignedIntTypeOperationFilterInput
  serie: SerieFilterInput
  notation: OptionFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input AlbumInput {
  anneeParution: Year
  associations: [String!]!
  auteursAlbums: [AuteurAlbumInput!]!
  editionsAlbums: [EditionAlbumInput!]!
  genresAlbums: [GenreAlbumInput!]!
  horsSerie: Boolean
  id: ID!
  integrale: Boolean
  moisParution: Month
  notation: OptionInput
  notes: String
  serie: SerieInput
  sujet: String
  titre: String
  tome: UnsignedShort
  tomeDebut: UnsignedShort
  tomeFin: UnsignedShort
  universAlbums: [UniversAlbumInput!]!
}

input AlbumSortInput {
  titre: SortEnumType
  titreRaw: SortEnumType
  sujet: SortEnumType
  sujetRaw: SortEnumType
  notes: SortEnumType
  notesRaw: SortEnumType
  horsSerie: SortEnumType
  tome: SortEnumType
  integrale: SortEnumType
  tomeDebut: SortEnumType
  tomeFin: SortEnumType
  moisParution: SortEnumType
  anneeParution: SortEnumType
  serieId: SortEnumType
  serie: SerieSortInput
  notationId: SortEnumType
  notation: OptionSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input AuteurAlbumInput {
  album: AlbumInput!
  auteur: AuteurInput!
  id: ID!
}

input AuteurFilterInput {
  and: [AuteurFilterInput!]
  or: [AuteurFilterInput!]
  personne: PersonneFilterInput
  metier: MetierOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input AuteurInput {
  auteursAlbums: [AuteurAlbumInput!]!
  auteursSeries: [AuteurSerieInput!]!
  id: ID!
  metier: Metier!
  personne: PersonneInput!
}

input AuteurSerieInput {
  auteur: AuteurInput!
  id: ID!
  serie: SerieInput!
}

input AuteurSortInput {
  personneId: SortEnumType
  personne: PersonneSortInput
  metier: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input CollectionFilterInput {
  and: [CollectionFilterInput!]
  or: [CollectionFilterInput!]
  nom: StringOperationFilterInput
  editeur: EditeurFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input CollectionInput {
  associations: [String!]!
  editeur: EditeurInput!
  editionsAlbums: [EditionAlbumInput!]!
  id: ID!
  nom: String!
  series: [SerieInput!]!
}

input CollectionSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  editeurId: SortEnumType
  editeur: EditeurSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input ComparableNonNullTypeOfUnsignedIntTypeOperationFilterInput {
  eq: UnsignedInt
  neq: UnsignedInt
  in: [UnsignedInt!]
  nin: [UnsignedInt!]
  gt: UnsignedInt
  ngt: UnsignedInt
  gte: UnsignedInt
  ngte: UnsignedInt
  lt: UnsignedInt
  nlt: UnsignedInt
  lte: UnsignedInt
  nlte: UnsignedInt
}

input ComparableUnsignedIntTypeOperationFilterInput {
  eq: UnsignedInt
  neq: UnsignedInt
  in: [UnsignedInt]
  nin: [UnsignedInt]
  gt: UnsignedInt
  ngt: UnsignedInt
  gte: UnsignedInt
  ngte: UnsignedInt
  lt: UnsignedInt
  nlt: UnsignedInt
  lte: UnsignedInt
  nlte: UnsignedInt
}

input CoteFilterInput {
  and: [CoteFilterInput!]
  or: [CoteFilterInput!]
  editionAlbum: EditionAlbumFilterInput
  annee: ComparableNonNullTypeOfUnsignedIntTypeOperationFilterInput
  prix: DecimalOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input CoteInput {
  annee: Year
  editionAlbum: EditionAlbumInput!
  id: ID!
  prix: EuroCurrency
}

input CoteSortInput {
  editionAlbumId: SortEnumType
  editionAlbum: EditionAlbumSortInput
  annee: SortEnumType
  prix: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input CreateGenreInput {
  genre: GenreInput!
}

input DateOperationFilterInput {
  eq: Date
  neq: Date
  in: [Date]
  nin: [Date]
  gt: Date
  ngt: Date
  gte: Date
  ngte: Date
  lt: Date
  nlt: Date
  lte: Date
  nlte: Date
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input DecimalOperationFilterInput {
  eq: Decimal
  neq: Decimal
  in: [Decimal]
  nin: [Decimal]
  gt: Decimal
  ngt: Decimal
  gte: Decimal
  ngte: Decimal
  lt: Decimal
  nlt: Decimal
  lte: Decimal
  nlte: Decimal
}

input DeleteAlbumInput {
  id: ID!
}

input DeleteCollectionInput {
  id: ID!
}

input DeleteEditeurInput {
  id: ID!
}

input DeleteEditionInput {
  id: ID!
}

input DeleteGenreInput {
  id: ID!
}

input DeleteImageInput {
  id: ID!
}

input DeletePersonneInput {
  id: ID!
}

input DeleteSerieInput {
  id: ID!
}

input DeleteUniversInput {
  id: ID!
}

input EditeurFilterInput {
  and: [EditeurFilterInput!]
  or: [EditeurFilterInput!]
  nom: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input EditeurInput {
  associations: [String!]!
  collections: [CollectionInput!]!
  editionsAlbums: [EditionAlbumInput!]!
  id: ID!
  nom: String!
  series: [SerieInput!]!
  siteWeb: URL
}

input EditeurSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  siteWeb: UriSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input EditionAlbumFilterInput {
  and: [EditionAlbumFilterInput!]
  or: [EditionAlbumFilterInput!]
  edition: EditionFilterInput
  album: AlbumFilterInput
  editeur: EditeurFilterInput
  collection: CollectionFilterInput
  etat: OptionFilterInput
  stock: BooleanOperationFilterInput
  offert: BooleanOperationFilterInput
  occasion: BooleanOperationFilterInput
  gratuit: BooleanOperationFilterInput
  dateAchat: DateOperationFilterInput
  prix: DecimalOperationFilterInput
  dedicace: BooleanOperationFilterInput
  numeroPerso: StringOperationFilterInput
  notes: StringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input EditionAlbumInput {
  album: AlbumInput!
  collection: CollectionInput
  cotes: [CoteInput!]!
  dateAchat: Date
  dedicace: Boolean
  editeur: EditeurInput!
  edition: EditionInput!
  etat: OptionInput
  gratuit: Boolean
  id: ID!
  images: [ImageInput!]!
  notes: String
  numeroPerso: String
  occasion: Boolean
  offert: Boolean
  prix: EuroCurrency
  stock: Boolean!
}

input EditionAlbumSortInput {
  editionId: SortEnumType
  edition: EditionSortInput
  albumId: SortEnumType
  album: AlbumSortInput
  editeurId: SortEnumType
  editeur: EditeurSortInput
  collectionId: SortEnumType
  collection: CollectionSortInput
  etatId: SortEnumType
  etat: OptionSortInput
  stock: SortEnumType
  offert: SortEnumType
  occasion: SortEnumType
  gratuit: SortEnumType
  dateAchat: SortEnumType
  prix: SortEnumType
  dedicace: SortEnumType
  numeroPerso: SortEnumType
  notes: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input EditionFilterInput {
  and: [EditionFilterInput!]
  or: [EditionFilterInput!]
  anneeEdition: ComparableUnsignedIntTypeOperationFilterInput
  notes: StringOperationFilterInput
  isbn: StringOperationFilterInput
  nombreDePages: ComparableUnsignedIntTypeOperationFilterInput
  couleur: BooleanOperationFilterInput
  vo: BooleanOperationFilterInput
  reliure: OptionFilterInput
  formatEdition: OptionFilterInput
  typeEdition: OptionFilterInput
  orientation: OptionFilterInput
  sensLecture: OptionFilterInput
  serie: SerieFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input EditionInput {
  anneeEdition: Year
  couleur: Boolean
  editionsAlbums: [EditionAlbumInput!]!
  formatEdition: OptionInput
  id: ID!
  isbn: Isbn
  nombreDePages: UnsignedShort
  notes: String
  orientation: OptionInput
  reliure: OptionInput
  sensLecture: OptionInput
  serie: SerieInput
  typeEdition: OptionInput
  vo: Boolean
}

input EditionSortInput {
  anneeEdition: SortEnumType
  notes: SortEnumType
  notesRaw: SortEnumType
  isbn: SortEnumType
  nombreDePages: SortEnumType
  couleur: SortEnumType
  vo: SortEnumType
  reliureId: SortEnumType
  reliure: OptionSortInput
  formatEditionId: SortEnumType
  formatEdition: OptionSortInput
  typeEditionId: SortEnumType
  typeEdition: OptionSortInput
  orientationId: SortEnumType
  orientation: OptionSortInput
  sensLectureId: SortEnumType
  sensLecture: OptionSortInput
  serie: SerieSortInput
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input GenreAlbumInput {
  album: AlbumInput!
  fromSerie: Boolean!
  genre: GenreInput!
  id: ID!
}

input GenreFilterInput {
  and: [GenreFilterInput!]
  or: [GenreFilterInput!]
  nom: StringOperationFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input GenreInput {
  associations: [String!]!
  genresAlbums: [GenreAlbumInput!]!
  genresSeries: [GenreSerieInput!]!
  id: ID!
  nom: String!
}

input GenreSerieInput {
  genre: GenreInput!
  id: ID!
  serie: SerieInput!
}

input GenreSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input IdOperationFilterInput {
  eq: ID
  neq: ID
  in: [ID]
  nin: [ID]
}

input ImageFilterInput {
  and: [ImageFilterInput!]
  or: [ImageFilterInput!]
  titre: StringOperationFilterInput
  ordre: ComparableNonNullTypeOfUnsignedIntTypeOperationFilterInput
  type: OptionFilterInput
  edition: EditionAlbumFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input ImageInput {
  edition: EditionAlbumInput!
  id: ID!
  ordre: UnsignedShort!
  titre: String
  type: OptionInput!
}

input ImageSortInput {
  titre: SortEnumType
  ordre: SortEnumType
  typeId: SortEnumType
  type: OptionSortInput
  editionId: SortEnumType
  edition: EditionAlbumSortInput
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  none: StringOperationFilterInput
  some: StringOperationFilterInput
  any: Boolean
}

input MetierOperationFilterInput {
  eq: Metier
  neq: Metier
  in: [Metier!]
  nin: [Metier!]
}

input OptionFilterInput {
  and: [OptionFilterInput!]
  or: [OptionFilterInput!]
  category: IdOperationFilterInput
  libelle: StringOperationFilterInput
  ordre: ComparableNonNullTypeOfUnsignedIntTypeOperationFilterInput
  defaut: BooleanOperationFilterInput
  id: ComparableNonNullTypeOfUnsignedIntTypeOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input OptionInput {
  albums: [AlbumInput!]!
  category: ID!
  defaut: Boolean!
  editionFormatEditions: [EditionInput!]!
  editionOrientations: [EditionInput!]!
  editionReliures: [EditionInput!]!
  editionsAlbums: [EditionAlbumInput!]!
  editionSensLectures: [EditionInput!]!
  editionTypeEditions: [EditionInput!]!
  id: ID!
  images: [ImageInput!]!
  libelle: String!
  ordre: UnsignedShort!
  series: [SerieInput!]!
}

input OptionSortInput {
  category: SortEnumType
  libelle: SortEnumType
  ordre: SortEnumType
  defaut: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input PersonneFilterInput {
  and: [PersonneFilterInput!]
  or: [PersonneFilterInput!]
  nom: StringOperationFilterInput
  biographie: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input PersonneInput {
  associations: [String!]!
  auteurs: [AuteurInput!]!
  biographie: String
  id: ID!
  nom: String!
  siteWeb: URL
}

input PersonneSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  biographie: SortEnumType
  biographieRaw: SortEnumType
  siteWeb: UriSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input SerieFilterInput {
  and: [SerieFilterInput!]
  or: [SerieFilterInput!]
  titre: StringOperationFilterInput
  sujet: StringOperationFilterInput
  notes: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  editeur: EditeurFilterInput
  collection: CollectionFilterInput
  modeleEdition: EditionFilterInput
  nbAlbums: ComparableUnsignedIntTypeOperationFilterInput
  terminee: BooleanOperationFilterInput
  complete: BooleanOperationFilterInput
  suivreSorties: BooleanOperationFilterInput
  suivreManquants: BooleanOperationFilterInput
  notation: OptionFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input SerieInput {
  albums: [AlbumInput!]!
  associations: [String!]!
  auteursSeries: [AuteurSerieInput!]!
  collection: CollectionInput
  complete: Boolean
  editeur: EditeurInput
  genresSeries: [GenreSerieInput!]!
  id: ID!
  modeleEdition: EditionInput!
  nbAlbums: UnsignedShort
  notation: OptionInput
  notes: String
  siteWeb: URL
  suivreManquants: Boolean
  suivreSorties: Boolean
  sujet: String
  terminee: Boolean
  titre: String
  universSeries: [UniversSerieInput!]!
}

input SerieSortInput {
  titre: SortEnumType
  titreRaw: SortEnumType
  sujet: SortEnumType
  sujetRaw: SortEnumType
  notes: SortEnumType
  notesRaw: SortEnumType
  siteWeb: UriSortInput
  editeurId: SortEnumType
  editeur: EditeurSortInput
  collectionId: SortEnumType
  collection: CollectionSortInput
  modeleEditionId: SortEnumType
  modeleEdition: EditionSortInput
  nbAlbums: SortEnumType
  terminee: SortEnumType
  complete: SortEnumType
  suivreSorties: SortEnumType
  suivreManquants: SortEnumType
  notationId: SortEnumType
  notation: OptionSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input UniversAlbumInput {
  album: AlbumInput!
  fromSerie: Boolean!
  id: ID!
  univers: UniversInput!
}

input UniversFilterInput {
  and: [UniversFilterInput!]
  or: [UniversFilterInput!]
  nom: StringOperationFilterInput
  description: StringOperationFilterInput
  siteWeb: UrlOperationFilterInput
  racine: UniversFilterInput
  parent: UniversFilterInput
  initiale: StringOperationFilterInput
  associations: ListStringOperationFilterInput
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input UniversInput {
  associations: [String!]!
  description: String
  id: ID!
  nom: String!
  parent: UniversInput
  racine: UniversInput!
  siteWeb: URL
  universAlbums: [UniversAlbumInput!]!
  universBranches: [UUID!]
  universParents: [UniversInput!]!
  universRacines: [UniversInput!]!
  universSeries: [UniversSerieInput!]!
}

input UniversSerieInput {
  id: ID!
  serie: SerieInput!
  univers: UniversInput!
}

input UniversSortInput {
  nom: SortEnumType
  nomRaw: SortEnumType
  description: SortEnumType
  descriptionRaw: SortEnumType
  siteWeb: UriSortInput
  universRacineId: SortEnumType
  racine: UniversSortInput
  universParentId: SortEnumType
  parent: UniversSortInput
  initiale: SortEnumType
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

input UpdateGenreInput {
  genre: GenreInput!
}

input UploadImagePictureInput {
  file: Upload
  id: ID!
}

input UriSortInput {
  absolutePath: SortEnumType
  absoluteUri: SortEnumType
  localPath: SortEnumType
  authority: SortEnumType
  hostNameType: SortEnumType
  isDefaultPort: SortEnumType
  isFile: SortEnumType
  isLoopback: SortEnumType
  pathAndQuery: SortEnumType
  isUnc: SortEnumType
  host: SortEnumType
  port: SortEnumType
  query: SortEnumType
  fragment: SortEnumType
  scheme: SortEnumType
  originalString: SortEnumType
  dnsSafeHost: SortEnumType
  idnHost: SortEnumType
  isAbsoluteUri: SortEnumType
  userEscaped: SortEnumType
  userInfo: SortEnumType
}

input UrlOperationFilterInput {
  eq: URL
  neq: URL
  in: [URL]
  nin: [URL]
  gt: URL
  ngt: URL
  gte: URL
  ngte: URL
  lt: URL
  nlt: URL
  lte: URL
  nlte: URL
}

input UuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

enum Metier {
  SCENARISTE
  DESSINATEUR
  COLORISTE
}

enum OptionCategory {
  EDITION_ETAT
  EDITION_RELIURE
  EDITION_TYPE
  EDITION_ORIENTATION
  EDITION_FORMAT
  IMAGE_TYPE
  EDITION_SENS_LECTURE
  NOTATION
}

enum SortEnumType {
  ASC
  DESC
}

directive @nullBubbling(enable: Boolean! = true) on QUERY | MUTATION | SUBSCRIPTION

"The `Date` scalar represents an ISO-8601 compliant date type."
scalar Date

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The built-in `Decimal` scalar type."
scalar Decimal

scalar EuroCurrency

"The ISBN scalar type is a ISBN-10 or ISBN-13 number: https:\/\/en.wikipedia.org\/wiki\/International_Standard_Book_Number."
scalar Isbn

"Value between 1 and 12"
scalar Month

scalar URL @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc3986")

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")

"The UnsignedInt scalar type represents a unsigned 32-bit numeric non-fractional value greater than or equal to 0."
scalar UnsignedInt

"The UnsignedShort scalar type represents a unsigned 16-bit numeric non-fractional value greater than or equal to 0."
scalar UnsignedShort

"The `Upload` scalar type represents a file upload."
scalar Upload

"Value between 1900 and 2999"
scalar Year
