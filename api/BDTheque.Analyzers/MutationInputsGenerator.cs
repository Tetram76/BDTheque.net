namespace BDTheque.Analyzers;

using System.Collections.Immutable;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class MutationInputsGenerator : IIncrementalGenerator
{
    private const string InputTypeSuffix = "Input";
    private const string InputsNamespaceName = "BDTheque.Model.Inputs";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<GeneratorSyntaxContext> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) => ctx
            )
            .Where(static ctx => IsClassAnnotatedWithObjectType(ctx));

        context.RegisterSourceOutput(
            classDeclarations,
            static (sourceContext, generatorContext) => GenerateInputType(sourceContext, generatorContext)
        );

        // IncrementalValueProvider<(Compilation Left, ImmutableArray<GeneratorSyntaxContext> Right)> valueProvider = context.CompilationProvider.Combine(classDeclarations.Collect());
        // context.RegisterSourceOutput(
        //     valueProvider,
        //     static (productionContext, tuple) => GenerateHotChocolateRegisters(productionContext, tuple.Right)
        // );
    }

    private static bool IsClassAnnotatedWithObjectType(GeneratorSyntaxContext ctx)
    {
        SemanticModel model = ctx.SemanticModel;
        if (model.GetDeclaredSymbol(ctx.Node) is not { } classSymbol) return false;
        if (model.Compilation.GetTypeByMetadataName("HotChocolate.Types.ObjectTypeAttribute") is not { } objectTypeAttributeSymbol) return false;

        return classSymbol
            .GetAttributes()
            .Any(attr => attr.AttributeClass != null && attr.AttributeClass.Equals(objectTypeAttributeSymbol, SymbolEqualityComparer.Default));
    }

    private static ClassDeclarationSyntax? GenerateInputType(SourceProductionContext productionContext, GeneratorSyntaxContext generatorContext)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;
        (CompilationUnitSyntax compilationUnitSyntax, ClassDeclarationSyntax classDeclarationSyntax)? classSource = GenerateClassSource(classDeclaration, generatorContext);
        if (classSource is null)
            return null;

        string sourceText = classSource.Value.compilationUnitSyntax.NormalizeWhitespace().ToFullString();
        productionContext.AddSource($"{classDeclaration.Identifier.Text}Inputs.g.cs", sourceText);

        return classSource.Value.classDeclarationSyntax;
    }

    private static (CompilationUnitSyntax, ClassDeclarationSyntax)? GenerateClassSource(ClassDeclarationSyntax classDeclaration, GeneratorSyntaxContext generatorContext)
    {
        if (generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration) is not { } classSymbol) return null;
        if ((classSymbol.BaseType is not { } baseTypeSymbol) || (baseTypeSymbol.SpecialType == SpecialType.System_Object)) return null;

        var baseClassName = baseTypeSymbol.ToDisplayParts().Last().ToString();
        if (!baseClassName.EndsWith("Entity"))
            return null;

        ClassDeclarationSyntax newClassDeclaration = GenerateInputClassDeclaration(generatorContext, classDeclaration, baseClassName.Remove(baseClassName.Length - "Entity".Length));

        return (
            SyntaxFactory
                .CompilationUnit()
                .AddUsings(classDeclaration.SyntaxTree.GetCompilationUnitRoot().Members.OfType<BaseNamespaceDeclarationSyntax>().SelectMany(syntax => syntax.Usings).ToArray())
                .AddUsings(
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(classSymbol.ContainingNamespace.ToDisplayString())),
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("HotChocolate.Types"))
                )
                .AddMembers(
                    SyntaxFactory
                        .NamespaceDeclaration(SyntaxFactory.IdentifierName(InputsNamespaceName)) // the generated source is more readable than with a FileScopedNamespaceDeclaration
                        .AddMembers(
                            newClassDeclaration
                        )
                )
                .NormalizeWhitespace()
                .WithLeadingTrivia(
                    SyntaxFactory.Comment("// <auto-generated/>"),
                    SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), true))
                ),
            newClassDeclaration
        );
    }

    private static ClassDeclarationSyntax GenerateInputClassDeclaration(GeneratorSyntaxContext generatorContext, ClassDeclarationSyntax classDeclaration, string baseClassName)
    {
        ClassDeclarationSyntax classBuilder = SyntaxFactory
            .ClassDeclaration(classDeclaration.Identifier.Text + InputTypeSuffix)
            .WithModifiers(classDeclaration.Modifiers)
            .AddBaseListTypes(
                SyntaxFactory.SimpleBaseType(SyntaxFactory.IdentifierName(baseClassName + InputTypeSuffix))
            )
            .AddGeneratedAttribute<MutationInputsGenerator>()
            .AddMembers(
                classDeclaration.Members
                    .OfType<PropertyDeclarationSyntax>()
                    .Select(
                        property => property // duplicate original property with some alterations
                            .WithType(
                                SyntaxFactory
                                    .GenericName(SyntaxFactory.Identifier("global::HotChocolate.Optional"))
                                    .AddTypeArgumentListArguments(RewriteType(generatorContext.SemanticModel, property.Type))
                            )
                            .WithInitializer(null).WithSemicolonToken(default)
                    )
                    .Cast<MemberDeclarationSyntax>()
                    .ToArray()
            );
        return classBuilder;
    }

    private static TypeSyntax RewriteType(SemanticModel generatorContextSemanticModel, TypeSyntax propertyType) =>
        propertyType switch
        {
            NullableTypeSyntax nullableTypeSyntax =>
                nullableTypeSyntax.WithElementType(RewriteType(generatorContextSemanticModel, nullableTypeSyntax.ElementType)),
            ArrayTypeSyntax arrayTypeSyntax =>
                arrayTypeSyntax.WithElementType(RewriteType(generatorContextSemanticModel, arrayTypeSyntax.ElementType)),
            GenericNameSyntax genericNameSyntax =>
                genericNameSyntax.WithTypeArgumentList( // not AddTypeArgumentListArguments: we have to replace the original list
                    SyntaxFactory.TypeArgumentList(
                        SyntaxFactory.SeparatedList(
                            genericNameSyntax.TypeArgumentList.Arguments.Select(syntax => RewriteType(generatorContextSemanticModel, syntax))
                        )
                    )
                ),
            _ =>
                IsEntityType(generatorContextSemanticModel, propertyType)
                    ? SyntaxFactory.IdentifierName(propertyType + InputTypeSuffix) // brand new type
                    : propertyType // nothing to change
        };

    private static bool IsEntityType(SemanticModel model, TypeSyntax typeSyntax)
    {
        ITypeSymbol? typeSymbol = model.GetTypeInfo(typeSyntax).Type;
        INamedTypeSymbol? baseClassSymbol = typeSymbol?.BaseType;
        while (baseClassSymbol != null)
        {
            if (baseClassSymbol.MetadataName == "VersioningEntity")
                return true;
            baseClassSymbol = baseClassSymbol.BaseType;
        }

        return false;
    }

    private static void GenerateHotChocolateRegisters(SourceProductionContext sourceProductionContext, ImmutableArray<GeneratorSyntaxContext> generatorContexts)
    {
        if (generatorContexts.IsEmpty) return;

        var typesRegister = generatorContexts
            .Select(generatorSyntaxContext => GenerateInputType(sourceProductionContext, generatorSyntaxContext))
            .OfType<ClassDeclarationSyntax>() // exclude nulls
            .Select(
                classDeclaration => SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.InvocationExpression(
                        // builder.AddType<global::BDTheque.Model.Entities.Album>();
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName("builder"),
                            SyntaxFactory
                                .GenericName(SyntaxFactory.Identifier("AddType"))
                                .AddTypeArgumentListArguments(
                                    SyntaxFactory.IdentifierName($"global::{InputsNamespaceName}.{classDeclaration.Identifier.Text}")
                                )
                        )
                    )
                )
            )
            .Cast<StatementSyntax>()
            .ToArray();

        if (typesRegister.Length == 0)
            return;

        TypeSyntax requestExecutorBuilderType = SyntaxFactory.IdentifierName("IRequestExecutorBuilder");
        ClassDeclarationSyntax staticClass = SyntaxFactory
            // public static partial class BDThequeGraphQLTypesRequestExecutorBuilderExtensions
            .ClassDeclaration("BDThequeGraphQLTypesRequestExecutorBuilderExtensions")
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.StaticKeyword),
                SyntaxFactory.Token(SyntaxKind.PartialKeyword)
            )
            // public static IRequestExecutorBuilder AddBDThequeGraphQLTypes(this IRequestExecutorBuilder builder)
            .AddMembers(
                SyntaxFactory
                    .MethodDeclaration(requestExecutorBuilderType, SyntaxFactory.ParseToken("AddBDThequeGraphQLInputTypes"))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword)
                    )
                    .AddParameterListParameters(
                        SyntaxFactory.Parameter(SyntaxFactory.Identifier("builder")).WithType(requestExecutorBuilderType).AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    )
                    .AddBodyStatements(typesRegister)
                    .AddBodyStatements(
                        SyntaxFactory.ReturnStatement(SyntaxFactory.IdentifierName("builder"))
                    )
            );

        string sourceCode = SyntaxFactory
            .NamespaceDeclaration(SyntaxFactory.IdentifierName("Microsoft.Extensions.DependencyInjection"))
            .AddUsings(
                SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("HotChocolate.Execution.Configuration")),
                SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(InputsNamespaceName))
            )
            .AddMembers(staticClass)
            .NormalizeWhitespace()
            .ToFullString();
        sourceProductionContext.AddSource("HotChocolateRegisterTypes.g.cs", sourceCode);
    }
}
