namespace BDTheque.Analyzers;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class MutationInputsGenerator : IIncrementalGenerator
{
    private const string CreateInputTypeSuffix = "CreateInput";
    private const string UpdateInputTypeSuffix = "UpdateInput";
    private const string NestedTypeSuffix = "NestedInput";
    private const string InputsNamespaceName = "BDTheque.Model.Inputs";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<GeneratorSyntaxContext> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) => ctx
            )
            .Where(static ctx => IsClassAnnotatedWithObjectType(ctx));

        context.RegisterSourceOutput(
            classDeclarations,
            static (sourceContext, generatorContext) => GenerateInputTypes(sourceContext, generatorContext)
        );
    }

    private static bool IsClassAnnotatedWithObjectType(GeneratorSyntaxContext ctx) =>
        IsSyntaxNodeAnnotatedWithAttribute(ctx, ctx.Node, "HotChocolate.Types.ObjectTypeAttribute");

    private static bool IsPropertyAnnotatedWithIdType(GeneratorSyntaxContext ctx, PropertyDeclarationSyntax propertySyntax) =>
        IsSyntaxNodeAnnotatedWithAttribute(ctx, propertySyntax, "HotChocolate.Types.Relay.IDAttribute");

    private static bool IsSyntaxNodeAnnotatedWithAttribute(GeneratorSyntaxContext ctx, SyntaxNode syntaxNode, string attributeFullClassName)
    {
        SemanticModel model = ctx.SemanticModel;
        if (model.GetDeclaredSymbol(syntaxNode) is not { } nodeSymbol) return false;
        if (model.Compilation.GetTypeByMetadataName(attributeFullClassName) is not { } attributeSymbol) return false;

        return nodeSymbol
            .GetAttributes()
            .Any(attr => attr.AttributeClass != null && attr.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default));
    }

    private static void GenerateInputTypes(SourceProductionContext sourceContext, GeneratorSyntaxContext generatorContext)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;
        CompilationUnitSyntax? compilationUnitSyntax = GenerateClassSource(classDeclaration, generatorContext);
        if (compilationUnitSyntax is null) return;

        string sourceText = compilationUnitSyntax.NormalizeWhitespace().ToFullString();
        sourceContext.AddSource($"{classDeclaration.Identifier.Text}Inputs.g.cs", sourceText);
    }

    private static CompilationUnitSyntax? GenerateClassSource(ClassDeclarationSyntax classDeclaration, GeneratorSyntaxContext generatorContext)
    {
        if (generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration) is not { } classSymbol) return null;
        if ((classSymbol.BaseType is not { } baseTypeSymbol) || (baseTypeSymbol.SpecialType == SpecialType.System_Object)) return null;

        const string entitySuffix = "Entity";
        var baseClassName = baseTypeSymbol.ToDisplayParts().Last().ToString();
        if (!baseClassName.EndsWith(entitySuffix))
            return null;
        baseClassName = baseClassName[..^entitySuffix.Length];

        ClassDeclarationSyntax[] inputClassesDeclaration = GenerateInputClassesDeclaration(generatorContext, classDeclaration, baseClassName);
        ClassDeclarationSyntax nestedClassDeclaration = GenerateNestedClassDeclaration(generatorContext, classDeclaration, baseClassName);

        return
            SyntaxFactory
                .CompilationUnit()
                .AddUsings(classDeclaration.SyntaxTree.GetCompilationUnitRoot().Members.OfType<BaseNamespaceDeclarationSyntax>().SelectMany(syntax => syntax.Usings).ToArray())
                .AddUsings(
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(classSymbol.ContainingNamespace.ToDisplayString())),
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("HotChocolate.Types"))
                )
                .AddMembers(
                    SyntaxFactory
                        .NamespaceDeclaration(SyntaxFactory.IdentifierName(InputsNamespaceName)) // the generated source is more readable than with a FileScopedNamespaceDeclaration
                        .AddMembers(
                            inputClassesDeclaration.OfType<MemberDeclarationSyntax>().ToArray()
                        )
                        .AddMembers(
                            nestedClassDeclaration
                        )
                )
                .NormalizeWhitespace()
                .WithLeadingTrivia(
                    SyntaxFactory.Comment("// <auto-generated/>"),
                    SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), true))
                );
    }

    private static ClassDeclarationSyntax GenerateInputClassDeclaration(GeneratorSyntaxContext generatorContext, ClassDeclarationSyntax classDeclaration, string baseClassName, string classSuffix) =>
        SyntaxFactory
            .ClassDeclaration(classDeclaration.Identifier.Text + classSuffix)
            .WithModifiers(classDeclaration.Modifiers)
            .AddBaseListTypes(
                SyntaxFactory.SimpleBaseType(SyntaxFactory.IdentifierName(baseClassName + classSuffix))
            )
            .AddGeneratedAttribute<MutationInputsGenerator>()
            .AddMembers(
                classDeclaration.Members
                    .OfType<PropertyDeclarationSyntax>()
                    .Where(
                        property => !generatorContext.IsCollectionType(property.Type) &&
                                    !generatorContext.IsEntityIdProperty(property) &&
                                    !property.Identifier.Text.EndsWith("Raw")
                    )
                    .Select(
                        property => property // duplicate original property with some alterations
                            .WithType(
                                SyntaxFactory
                                    .GenericName(SyntaxFactory.Identifier("global::HotChocolate.Optional"))
                                    .AddTypeArgumentListArguments(generatorContext.RewriteType(property.Type, syntax => SyntaxFactory.IdentifierName(syntax + NestedTypeSuffix)))
                            )
                            .AddRequiredAttribute(classSuffix == CreateInputTypeSuffix && property.Type is not NullableTypeSyntax)
                            .WithInitializer(null).WithSemicolonToken(default)
                    )
                    .Cast<MemberDeclarationSyntax>()
                    .ToArray()
            );

    private static ClassDeclarationSyntax[] GenerateInputClassesDeclaration(GeneratorSyntaxContext generatorContext, ClassDeclarationSyntax classDeclaration, string baseClassName) =>
    [
        GenerateInputClassDeclaration(generatorContext, classDeclaration, baseClassName, CreateInputTypeSuffix),
        GenerateInputClassDeclaration(generatorContext, classDeclaration, baseClassName, UpdateInputTypeSuffix)
    ];

    private static ClassDeclarationSyntax GenerateNestedClassDeclaration(GeneratorSyntaxContext generatorContext, ClassDeclarationSyntax classDeclaration, string baseClassName) =>
        SyntaxFactory
            .ClassDeclaration(classDeclaration.Identifier.Text + NestedTypeSuffix)
            .WithModifiers(classDeclaration.Modifiers)
            .AddBaseListTypes(
                SyntaxFactory.SimpleBaseType(SyntaxFactory.IdentifierName(baseClassName + NestedTypeSuffix))
            )
            .AddGeneratedAttribute<MutationInputsGenerator>()
            .AddMembers(
                classDeclaration.Members
                    .OfType<PropertyDeclarationSyntax>()
                    .Where(propertySyntax => IsPropertyAnnotatedWithIdType(generatorContext, propertySyntax))
                    .Select(property => property.AddRequiredAttribute())
                    .Cast<MemberDeclarationSyntax>()
                    .ToArray()
            );
}
