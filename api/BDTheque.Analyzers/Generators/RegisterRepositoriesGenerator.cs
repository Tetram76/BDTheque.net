namespace BDTheque.Analyzers.Generators;

using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class RegisterRepositoriesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is ClassDeclarationSyntax,
                static (ctx, _) => ctx
            )
            .Where(static ctx => ((ClassDeclarationSyntax) ctx.Node).IsAnnotatedWithEntityRepository(ctx))
            .Select(static (ctx, _) => ((ClassDeclarationSyntax) ctx.Node, ctx.SemanticModel));

        context.RegisterSourceOutput(
            classDeclarations.Collect(),
            static (sourceContext, classes) => GenerateSource(sourceContext, classes)
        );
    }

    private static void GenerateSource(SourceProductionContext sourceContext, ImmutableArray<(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)> classes)
    {
        if (classes.IsEmpty)
            return;

        if (GenerateCompilationUnit(classes) is not { } compilationUnitSyntax)
            return;

        string sourceText = compilationUnitSyntax.NormalizeWhitespace().ToFullString();
        sourceContext.AddSource("RepositoryRegistration.g.cs", sourceText);
    }

    private static CompilationUnitSyntax GenerateCompilationUnit(ImmutableArray<(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)> classes)
    {
        List<string> usings = [];
        return SyntaxFactory
            .CompilationUnit()
            .AddMembers(
                SyntaxFactory
                    .NamespaceDeclaration(SyntaxFactory.IdentifierName(WellKnownDefinitions.Microsoft.Extensions.DependencyInjection.Namespace)) // the generated source is more readable than with a FileScopedNamespaceDeclaration
                    .AddMembers(GenerateRegistrationClass(classes, usings))
            )
            .AddUsings(
                usings
                    .Distinct()
                    .ToImmutableSortedSet()
                    .Select(s => SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(s)))
                    .ToArray()
            )
            .NormalizeWhitespace()
            .SetAutoGenerated()
            .ActivateNullability();
    }

    private static ClassDeclarationSyntax GenerateRegistrationClass(ImmutableArray<(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)> classes, List<string> usings)
    {
        IdentifierNameSyntax servicesParameter = SyntaxFactory.IdentifierName("services");
        TypeSyntax serviceCollectionType = SyntaxFactory.ParseTypeName("IServiceCollection");
        return SyntaxFactory
            .ClassDeclaration("RepositoriesRegistration")
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.StaticKeyword)
            )
            .AddMembers(
                SyntaxFactory
                    .MethodDeclaration(serviceCollectionType, "AddRepositories")
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                        SyntaxFactory.Token(SyntaxKind.StaticKeyword)
                    )
                    .AddParameterListParameters(
                        SyntaxFactory
                            .Parameter(servicesParameter.Identifier).WithType(serviceCollectionType)
                            .AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                    )
                    .AddBodyStatements(
                        classes.SelectMany(context => GenerateRegisterService(context.semanticModel, context.classDeclarationSyntax, servicesParameter, usings)).ToArray()
                    )
                    .AddBodyStatements(
                        SyntaxFactory.ReturnStatement(servicesParameter)
                    )
            );
    }

    private static IEnumerable<StatementSyntax> GenerateRegisterService(SemanticModel semanticModel, ClassDeclarationSyntax classDeclarationSyntax, IdentifierNameSyntax servicesParameter, List<string> usings)
    {
        if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not { IsAbstract: false } classSymbol)
            return [];

        if (!classSymbol.IsAnnotatedWithAttribute(WellKnownDefinitions.BDTheque.Data.Attributes.EntityRepositoryAttribute, out AttributeData? attributeData))
            throw new InvalidOperationException($"Expected {classSymbol.Name} to have {WellKnownDefinitions.BDTheque.Data.Attributes.EntityRepositoryAttribute} attribute (directly or not) but is not");

        int lifetime = attributeData.ConstructorArguments.FirstOrDefault().Value as int? ?? 1;
        SyntaxToken registrationMethod = SyntaxFactory.Identifier(
            lifetime switch
            {
                0 => "AddSingleton",
                1 => "AddScoped",
                _ => "AddTransient"
            }
        );

        return classSymbol.AllInterfaces
            .Select(interfaceSymbol => GenerateRegistrationStatement(registrationMethod, classSymbol, interfaceSymbol, servicesParameter, usings));
    }

    private static StatementSyntax GenerateRegistrationStatement(SyntaxToken registrationMethod, INamedTypeSymbol classSymbol, INamedTypeSymbol interfaceSymbol, IdentifierNameSyntax servicesParameter, List<string> usings)
    {
        string className = classSymbol.Name;
        string interfaceName = interfaceSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        usings.Add(classSymbol.OriginalDefinition.ContainingNamespace.ToDisplayString());
        usings.Add(interfaceSymbol.OriginalDefinition.ContainingNamespace.ToDisplayString());
        if (interfaceSymbol.IsGenericType)
            usings.AddRange(interfaceSymbol.TypeArguments.Select(arg => arg.ContainingNamespace.ToDisplayString()));

        return SyntaxFactory.ExpressionStatement(
            SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    servicesParameter,
                    SyntaxFactory.GenericName(registrationMethod)
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.IdentifierName(interfaceName),
                            SyntaxFactory.IdentifierName(className)
                        )
                )
            )
        );
    }
}
