namespace BDTheque.Analyzers.Generators;

using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class MutationImplementationsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<GeneratorSyntaxContext> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) => ctx
            )
            .Where(static ctx => ((ClassDeclarationSyntax) ctx.Node).IsAnnotatedWithMutationType(ctx));

        context.RegisterSourceOutput(
            classDeclarations,
            static (sourceContext, generatorContext) => GenerateImplementations(sourceContext, generatorContext)
        );
    }

    private static void GenerateImplementations(SourceProductionContext sourceContext, GeneratorSyntaxContext generatorContext)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;

        CompilationUnitSyntax compilationUnitSyntax = GenerateCompilationUnit(classDeclaration, generatorContext);

        string sourceText = compilationUnitSyntax.NormalizeWhitespace().ToFullString();
        sourceContext.AddSource($"{classDeclaration.Identifier.Text}.g.cs", sourceText);
    }

    private static CompilationUnitSyntax GenerateCompilationUnit(ClassDeclarationSyntax classDeclaration, GeneratorSyntaxContext context)
    {
        ITypeSymbol entityClassSymbol = classDeclaration.GetEntityTypeFromAttribute(context);
        Compilation compilation = classDeclaration.SemanticModel(context).Compilation;

        ClassDeclarationSyntax mutationsClass = GenerateMutationsClass(classDeclaration);
        List<string> usings = [];
        if (entityClassSymbol.MutableProperties(compilation).Any(property => property.Type.IsEntityType(compilation)))
            mutationsClass = mutationsClass.WithMembers(
                mutationsClass.Members.Insert(0, GenerateInputInterfaceExtensionDeclaration(entityClassSymbol, compilation, usings))
            );

        return SyntaxFactory.CompilationUnit()
            .AddUsings(
                usings
                    .Concat([WellKnownDefinitions.InputsNamespaceName])
                    .Distinct()
                    .ToImmutableSortedSet()
                    .Select(s => SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(s)))
                    .ToArray()
            )
            .AddMembers(
                SyntaxFactory
                    .NamespaceDeclaration(classDeclaration.ContainingNamespace()) // the generated source is more readable than with a FileScopedNamespaceDeclaration
                    .AddMembers(
                        mutationsClass
                    )
            )
            .NormalizeWhitespace()
            .SetAutoGenerated()
            .ActivateNullability();
    }

    private static ClassDeclarationSyntax GenerateMutationsClass(ClassDeclarationSyntax classDeclaration) =>
        SyntaxFactory.ClassDeclaration(classDeclaration.Identifier)
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.StaticKeyword),
                SyntaxFactory.Token(SyntaxKind.PartialKeyword)
            )
            .AddGeneratedAttribute<MutationImplementationsGenerator>();

    private static MethodDeclarationSyntax GenerateInputInterfaceExtensionDeclaration(ITypeSymbol classSymbol, Compilation compilation, ICollection<string> usings)
    {
        TypeSyntax entityTypeSyntax = SyntaxFactory.ParseTypeName(classSymbol.Name);
        usings.Add(classSymbol.OriginalDefinition.ContainingNamespace.ToDisplayString());

        IdentifierNameSyntax inputIdentifier = SyntaxFactory.IdentifierName("input");
        IdentifierNameSyntax entityIdentifier = SyntaxFactory.IdentifierName("entity");
        IdentifierNameSyntax serviceProviderIdentifier = SyntaxFactory.IdentifierName("serviceProvider");

        List<ParameterSyntax> parameters =
        [
            SyntaxFactory.Parameter(inputIdentifier.Identifier).WithType(SyntaxFactory.ParseTypeName("I" + classSymbol.Name + "InputType"))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.ThisKeyword)),
            SyntaxFactory.Parameter(entityIdentifier.Identifier).WithType(entityTypeSyntax),
            SyntaxFactory.Parameter(serviceProviderIdentifier.Identifier).WithType(
                SyntaxFactory.ParseTypeName(WellKnownDefinitions.System.ServiceProvider.Split('.')[^1])
            ),
            SyntaxFactory.Parameter(SyntaxFactory.Identifier("cancellationToken")).WithType(SyntaxFactory.ParseTypeName("CancellationToken"))
        ];
        usings.Add(WellKnownDefinitions.System.ServiceProvider.Split('.').SkipLast(1).Aggregate((s, s1) => $"{s}.{s1}"));

        IEnumerable<IPropertySymbol> entityProperties = classSymbol.MutableProperties(compilation)
            .Where(property => property.Type.IsEntityType(compilation))
            .ToArray();
        return SyntaxFactory
            .MethodDeclaration(SyntaxFactory.GenericName("Task").AddTypeArgumentListArguments(entityTypeSyntax), "ApplyTo")
            .AddModifiers(
                SyntaxFactory.Token(SyntaxKind.InternalKeyword),
                SyntaxFactory.Token(SyntaxKind.StaticKeyword)
            )
            .AddParameterListParameters(
                parameters.ToArray()
            )
            .WithBody(
                SyntaxFactory.Block()
                    .AddStatements(
                        entityProperties
                            .Select(property => GetterVariableExpression(property, serviceProviderIdentifier, usings))
                            .ToArray()
                    )
                    .AddStatements(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression, inputIdentifier, SyntaxFactory.IdentifierName("ApplyTo")
                                    )
                                )
                                .AddArgumentListArguments(
                                    SyntaxFactory.Argument(entityIdentifier)
                                )
                                .AddArgumentListArguments(
                                    entityProperties
                                        .Select(property => SyntaxFactory.Argument(SyntaxFactory.IdentifierName($"get{property.Name}")))
                                        .ToArray()
                                )
                        )
                    )
            );
    }

    private static StatementSyntax GetterVariableExpression(IPropertySymbol propertySymbol, IdentifierNameSyntax serviceProviderIdentifier, ICollection<string> usings)
    {
        ITypeSymbol entityTypeSymbol = propertySymbol.Type;
        usings.Add(entityTypeSymbol.OriginalDefinition.ContainingNamespace.ToDisplayString());
        ITypeSymbol? scalarType = propertySymbol.GetMutationType();

        return SyntaxFactory.LocalDeclarationStatement(
            SyntaxFactory.VariableDeclaration(
                    SyntaxFactory.GenericName("Func")
                        .AddTypeArgumentListArguments(
                            SyntaxFactory.ParseTypeName($"{(scalarType == null ? $"{entityTypeSymbol.Name}{WellKnownDefinitions.NestedTypeSuffix}" : "ushort")}{(entityTypeSymbol.IsNullable() ? "?" : "")}"),
                            SyntaxFactory.GenericName("Task").AddTypeArgumentListArguments(SyntaxFactory.ParseTypeName(entityTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)))
                        )
                )
                .AddVariables(
                    SyntaxFactory.VariableDeclarator(SyntaxFactory.Identifier($"get{propertySymbol.Name}"))
                        .WithInitializer(
                            SyntaxFactory.EqualsValueClause(
                                SearchEntityExpression(propertySymbol, serviceProviderIdentifier, usings)
                            )
                        )
                )
        );
    }

    private static ExpressionSyntax SearchEntityExpression(IPropertySymbol propertySymbol, IdentifierNameSyntax serviceProviderIdentifier, ICollection<string> usings)
    {
        IdentifierNameSyntax parameterIdentifier = SyntaxFactory.IdentifierName(propertySymbol.Name.ToCamelCase());
        IdentifierNameSyntax notNullParameterIdentifier = SyntaxFactory.IdentifierName($"{propertySymbol.Name.ToCamelCase()}.Value");
        IdentifierNameSyntax idIdentifier = SyntaxFactory.IdentifierName("Id");
        MemberAccessExpressionSyntax idAccessExpression = SyntaxFactory.MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression, parameterIdentifier, idIdentifier
        );

        ITypeSymbol entityTypeSymbol = propertySymbol.Type.OriginalDefinition;
        ITypeSymbol entityKeyTypeSymbol = entityTypeSymbol.EntityKeyTypeSymbol().OriginalDefinition;
        usings.Add(entityTypeSymbol.OriginalDefinition.ContainingNamespace.ToDisplayString());
        usings.Add(entityKeyTypeSymbol.ContainingNamespace.ToDisplayString());

        InvocationExpressionSyntax repositoryExpression = SyntaxFactory.InvocationExpression(
            SyntaxFactory.MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                serviceProviderIdentifier,
                SyntaxFactory.GenericName("GetRequiredService")
                    .AddTypeArgumentListArguments(
                        SyntaxFactory.GenericName(
                                WellKnownDefinitions.BDTheque.Data.Repositories.Interfaces.EntityRepositoryTypeName.Split('.')[^1]
                            )
                            .AddTypeArgumentListArguments(
                                SyntaxFactory.ParseTypeName(entityTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)),
                                SyntaxFactory.ParseTypeName(entityKeyTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat))
                            )
                    )
            )
        );
        usings.Add(WellKnownDefinitions.BDTheque.Data.Repositories.Interfaces.EntityRepositoryTypeName.Split('.').SkipLast(1).Aggregate((s, s1) => $"{s}.{s1}"));
        usings.Add(WellKnownDefinitions.Microsoft.Extensions.DependencyInjection.Namespace); // IServiceProvider.GetRequiredService()

        ExpressionSyntax argumentIdentifier;
        if (propertySymbol.GetMutationType() == null)
            argumentIdentifier = idAccessExpression;
        else
            argumentIdentifier = propertySymbol.Type.IsNullable() ? notNullParameterIdentifier : parameterIdentifier;

        ExpressionSyntax searchExpression = SyntaxFactory.AwaitExpression(
            SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression, repositoryExpression, SyntaxFactory.IdentifierName("GetById")
                )
            ).AddArgumentListArguments(
                SyntaxFactory.Argument(argumentIdentifier),
                SyntaxFactory.Argument(SyntaxFactory.IdentifierName("cancellationToken"))
            )
        );

        if (propertySymbol.Type.IsNullable())
            searchExpression = SyntaxFactory.ConditionalExpression(
                SyntaxFactory.BinaryExpression(
                    SyntaxKind.EqualsExpression, parameterIdentifier, SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)
                ),
                SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression),
                searchExpression
            );

        return SyntaxFactory.ParenthesizedLambdaExpression(
            SyntaxFactory.Token(SyntaxKind.AsyncKeyword),
            SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Parameter(parameterIdentifier.Identifier))),
            SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken),
            searchExpression
        );
    }
}
